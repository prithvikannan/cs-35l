From 46ea25e4e70e3d32f355aaca91efe7f678b17ea3 Mon Sep 17 00:00:00 2001
From: Prithvi Kannan <prithvik@lnxsrv05.seas.ucla.edu>
Date: Fri, 15 Nov 2019 11:04:31 -0800
Subject: [PATCH] 2019-11-15  Prithvi Kannan  <prithvik@lnxsrv05.seas.ucla.edu>

	* quote-3.0-patch.txt: This patches updates character string constanst in .c files to match an update where the quote style changes from `sample' or ``sample" to 'sample' or "sample" respectively.
---
 src/cmp.c.orig   |  685 +++++++++++++++++++++
 src/cmp.c.rej    |   76 +++
 src/diff.c.orig  | 1330 +++++++++++++++++++++++++++++++++++++++++
 src/diff3.c.orig | 1747 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/dir.c.orig   |  283 +++++++++
 src/sdiff.c.orig | 1236 ++++++++++++++++++++++++++++++++++++++
 src/util.c.orig  |  788 ++++++++++++++++++++++++
 7 files changed, 6145 insertions(+)
 create mode 100644 src/cmp.c.orig
 create mode 100644 src/cmp.c.rej
 create mode 100644 src/diff.c.orig
 create mode 100644 src/diff3.c.orig
 create mode 100644 src/dir.c.orig
 create mode 100644 src/sdiff.c.orig
 create mode 100644 src/util.c.orig

diff --git a/src/cmp.c.orig b/src/cmp.c.orig
new file mode 100644
index 0000000..905d121
--- /dev/null
+++ b/src/cmp.c.orig
@@ -0,0 +1,685 @@
+/* cmp - compare two files byte by byte
+
+   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <unlocked-io.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+#include <xstrtol.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "cmp"
+
+#define AUTHORS \
+  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
+  proper_name ("David MacKenzie")
+
+#if defined LC_MESSAGES && ENABLE_NLS
+# define hard_locale_LC_MESSAGES hard_locale (LC_MESSAGES)
+#else
+# define hard_locale_LC_MESSAGES 0
+#endif
+
+static int cmp (void);
+static off_t file_position (int);
+static size_t block_compare (word const *, word const *);
+static size_t block_compare_and_count (word const *, word const *, off_t *);
+static void sprintc (char *, unsigned char);
+
+/* Filenames of the compared files.  */
+static char const *file[2];
+
+/* File descriptors of the files.  */
+static int file_desc[2];
+
+/* Status of the files.  */
+static struct stat stat_buf[2];
+
+/* Read buffers for the files.  */
+static word *buffer[2];
+
+/* Optimal block size for the files.  */
+static size_t buf_size;
+
+/* Initial prefix to ignore for each file.  */
+static off_t ignore_initial[2];
+
+/* Number of bytes to compare.  */
+static uintmax_t bytes = UINTMAX_MAX;
+
+/* Output format.  */
+static enum comparison_type
+  {
+    type_first_diff,	/* Print the first difference.  */
+    type_all_diffs,	/* Print all differences.  */
+    type_no_stdout,	/* Do not output to stdout; only stderr.  */
+    type_status		/* Exit status only.  */
+  } comparison_type;
+
+/* If nonzero, print values of bytes quoted like cat -t does. */
+static bool opt_print_bytes;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  HELP_OPTION = CHAR_MAX + 1
+};
+
+static struct option const long_options[] =
+{
+  {"print-bytes", 0, 0, 'b'},
+  {"print-chars", 0, 0, 'c'}, /* obsolescent as of diffutils 2.7.3 */
+  {"ignore-initial", 1, 0, 'i'},
+  {"verbose", 0, 0, 'l'},
+  {"bytes", 1, 0, 'n'},
+  {"silent", 0, 0, 's'},
+  {"quiet", 0, 0, 's'},
+  {"version", 0, 0, 'v'},
+  {"help", 0, 0, HELP_OPTION},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static char const valid_suffixes[] = "kKMGTPEZY0";
+
+/* Update ignore_initial[F] according to the result of parsing an
+   *operand ARGPTR of --ignore-initial, updating *ARGPTR to point
+   *after the operand.  If DELIMITER is nonzero, the operand may be
+   *followed by DELIMITER; otherwise it must be null-terminated.  */
+static void
+specify_ignore_initial (int f, char **argptr, char delimiter)
+{
+  uintmax_t val;
+  char const *arg = *argptr;
+  strtol_error e = xstrtoumax (arg, argptr, 0, &val, valid_suffixes);
+  if (! (e == LONGINT_OK
+	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+      || TYPE_MAXIMUM (off_t) < val)
+    try_help ("invalid --ignore-initial value '%s'", arg);
+  if (ignore_initial[f] < val)
+    ignore_initial[f] = val;
+}
+
+/* Specify the output format.  */
+static void
+specify_comparison_type (enum comparison_type t)
+{
+  if (comparison_type && comparison_type != t)
+    try_help ("options -l and -s are incompatible", 0);
+  comparison_type = t;
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    error (EXIT_TROUBLE, 0, "%s", _("write failed"));
+  else if (fclose (stdout) != 0)
+    error (EXIT_TROUBLE, errno, "%s", _("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-b  --print-bytes  Print differing bytes."),
+  N_("-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."),
+  N_("-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"),
+  N_("  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."),
+  N_("-l  --verbose  Output byte numbers and values of all differing bytes."),
+  N_("-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."),
+  N_("-s  --quiet  --silent  Output nothing; yield exit status only."),
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare two files byte by byte."));
+  for (p = option_help_msgid;  *p;  p++)
+    printf ("  %s\n", _(*p));
+  printf ("\n%s\n%s\n\n%s\n%s\n",
+	  _("SKIP1 and SKIP2 are the number of bytes to skip in each file."),
+	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+	  _("If a FILE is '-' or missing, read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, f, exit_status;
+  size_t words_per_buffer;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  /* Parse command line options.  */
+
+  while ((c = getopt_long (argc, argv, "bci:ln:sv", long_options, 0))
+	 != -1)
+    switch (c)
+      {
+      case 'b':
+      case 'c': /* 'c' is obsolescent as of diffutils 2.7.3 */
+	opt_print_bytes = true;
+	break;
+
+      case 'i':
+	specify_ignore_initial (0, &optarg, ':');
+	if (*optarg++ == ':')
+	  specify_ignore_initial (1, &optarg, 0);
+	else if (ignore_initial[1] < ignore_initial[0])
+	  ignore_initial[1] = ignore_initial[0];
+	break;
+
+      case 'l':
+	specify_comparison_type (type_all_diffs);
+	break;
+
+      case 'n':
+	{
+	  uintmax_t n;
+	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+	    try_help ("invalid --bytes value '%s'", optarg);
+	  if (n < bytes)
+	    bytes = n;
+	}
+	break;
+
+      case 's':
+	specify_comparison_type (type_status);
+	break;
+
+      case 'v':
+	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		     AUTHORS, (char *) NULL);
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      case HELP_OPTION:
+	usage ();
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      default:
+	try_help (0, 0);
+      }
+
+  if (optind == argc)
+    try_help ("missing operand after '%s'", argv[argc - 1]);
+
+  file[0] = argv[optind++];
+  file[1] = optind < argc ? argv[optind++] : "-";
+
+  for (f = 0; f < 2 && optind < argc; f++)
+    {
+      char *arg = argv[optind++];
+      specify_ignore_initial (f, &arg, 0);
+    }
+
+  if (optind < argc)
+    try_help ("extra operand '%s'", argv[optind]);
+
+  for (f = 0; f < 2; f++)
+    {
+      /* If file[1] is "-", treat it first; this avoids a misdiagnostic if
+	 stdin is closed and opening file[0] yields file descriptor 0.  */
+      int f1 = f ^ (STREQ (file[1], "-"));
+
+      /* Two files with the same name and offset are identical.
+	 But wait until we open the file once, for proper diagnostics.  */
+      if (f && ignore_initial[0] == ignore_initial[1]
+	  && file_name_cmp (file[0], file[1]) == 0)
+	return EXIT_SUCCESS;
+
+      if (STREQ (file[f1], "-"))
+	{
+	  file_desc[f1] = STDIN_FILENO;
+	  if (O_BINARY && ! isatty (STDIN_FILENO))
+	    xfreopen (NULL, "rb", stdin);
+	}
+      else
+	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+
+      if (file_desc[f1] < 0 || fstat (file_desc[f1], stat_buf + f1) != 0)
+	{
+	  if (file_desc[f1] < 0 && comparison_type == type_status)
+	    exit (EXIT_TROUBLE);
+	  else
+	    error (EXIT_TROUBLE, errno, "%s", file[f1]);
+	}
+    }
+
+  /* If the files are links to the same inode and have the same file position,
+     they are identical.  */
+
+  if (0 < same_file (&stat_buf[0], &stat_buf[1])
+      && same_file_attributes (&stat_buf[0], &stat_buf[1])
+      && file_position (0) == file_position (1))
+    return EXIT_SUCCESS;
+
+  /* If output is redirected to the null device, we can avoid some of
+     the work.  */
+
+  if (comparison_type != type_status)
+    {
+      struct stat outstat, nullstat;
+
+      if (fstat (STDOUT_FILENO, &outstat) == 0
+	  && stat (NULL_DEVICE, &nullstat) == 0
+	  && 0 < same_file (&outstat, &nullstat))
+	comparison_type = type_no_stdout;
+    }
+
+  /* If only a return code is needed,
+     and if both input descriptors are associated with plain files,
+     conclude that the files differ if they have different sizes
+     and if more bytes will be compared than are in the smaller file.  */
+
+  if (comparison_type == type_status
+      && S_ISREG (stat_buf[0].st_mode)
+      && S_ISREG (stat_buf[1].st_mode))
+    {
+      off_t s0 = stat_buf[0].st_size - file_position (0);
+      off_t s1 = stat_buf[1].st_size - file_position (1);
+      if (s0 < 0)
+	s0 = 0;
+      if (s1 < 0)
+	s1 = 0;
+      if (s0 != s1 && MIN (s0, s1) < bytes)
+	exit (EXIT_FAILURE);
+    }
+
+  /* Get the optimal block size of the files.  */
+
+  buf_size = buffer_lcm (STAT_BLOCKSIZE (stat_buf[0]),
+			 STAT_BLOCKSIZE (stat_buf[1]),
+			 PTRDIFF_MAX - sizeof (word));
+
+  /* Allocate word-aligned buffers, with space for sentinels at the end.  */
+
+  words_per_buffer = (buf_size + 2 * sizeof (word) - 1) / sizeof (word);
+  buffer[0] = xmalloc (2 * sizeof (word) * words_per_buffer);
+  buffer[1] = buffer[0] + words_per_buffer;
+
+  exit_status = cmp ();
+
+  for (f = 0; f < 2; f++)
+    if (close (file_desc[f]) != 0)
+      error (EXIT_TROUBLE, errno, "%s", file[f]);
+  if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+    check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Compare the two files already open on 'file_desc[0]' and 'file_desc[1]',
+   using 'buffer[0]' and 'buffer[1]'.
+   Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+   >1 if error.  */
+
+static int
+cmp (void)
+{
+  off_t line_number = 1;	/* Line number (1...) of difference. */
+  off_t byte_number = 1;	/* Byte number (1...) of difference. */
+  uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+  size_t read0, read1;		/* Number of bytes read from each file. */
+  size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+  size_t smaller;		/* The lesser of 'read0' and 'read1'. */
+  word *buffer0 = buffer[0];
+  word *buffer1 = buffer[1];
+  char *buf0 = (char *) buffer0;
+  char *buf1 = (char *) buffer1;
+  int differing = 0;
+  int f;
+  int offset_width IF_LINT (= 0);
+
+  if (comparison_type == type_all_diffs)
+    {
+      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));
+
+      for (f = 0; f < 2; f++)
+	if (S_ISREG (stat_buf[f].st_mode))
+	  {
+	    off_t file_bytes = stat_buf[f].st_size - file_position (f);
+	    if (file_bytes < byte_number_max)
+	      byte_number_max = file_bytes;
+	  }
+
+      for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)
+	continue;
+    }
+
+  for (f = 0; f < 2; f++)
+    {
+      off_t ig = ignore_initial[f];
+      if (ig && file_position (f) == -1)
+	{
+	  /* lseek failed; read and discard the ignored initial prefix.  */
+	  do
+	    {
+	      size_t bytes_to_read = MIN (ig, buf_size);
+	      size_t r = block_read (file_desc[f], buf0, bytes_to_read);
+	      if (r != bytes_to_read)
+		{
+		  if (r == SIZE_MAX)
+		    error (EXIT_TROUBLE, errno, "%s", file[f]);
+		  break;
+		}
+	      ig -= r;
+	    }
+	  while (ig);
+	}
+    }
+
+  do
+    {
+      size_t bytes_to_read = buf_size;
+
+      if (remaining != UINTMAX_MAX)
+	{
+	  if (remaining < bytes_to_read)
+	    bytes_to_read = remaining;
+	  remaining -= bytes_to_read;
+	}
+
+      read0 = block_read (file_desc[0], buf0, bytes_to_read);
+      if (read0 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[0]);
+      read1 = block_read (file_desc[1], buf1, bytes_to_read);
+      if (read1 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[1]);
+
+      /* Insert sentinels for the block compare.  */
+
+      buf0[read0] = ~buf1[read0];
+      buf1[read1] = ~buf0[read1];
+
+      /* If the line number should be written for differing files,
+	 compare the blocks and count the number of newlines
+	 simultaneously.  */
+      first_diff = (comparison_type == type_first_diff
+		    ? block_compare_and_count (buffer0, buffer1, &line_number)
+		    : block_compare (buffer0, buffer1));
+
+      byte_number += first_diff;
+      smaller = MIN (read0, read1);
+
+      if (first_diff < smaller)
+	{
+	  switch (comparison_type)
+	    {
+	    case type_first_diff:
+	      {
+		char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		char const *byte_num = offtostr (byte_number, byte_buf);
+		char const *line_num = offtostr (line_number, line_buf);
+		if (!opt_print_bytes)
+		  {
+		    /* See POSIX 1003.1-2001 for this format.  This
+		       message is used only in the POSIX locale, so it
+		       need not be translated.  */
+		    static char const char_message[] =
+		      "%s %s differ: char %s, line %s\n";
+
+		    /* The POSIX rationale recommends using the word
+		       "byte" outside the POSIX locale.  Some gettext
+		       implementations translate even in the POSIX
+		       locale if certain other environment variables
+		       are set, so use "byte" if a translation is
+		       available, or if outside the POSIX locale.  */
+		    static char const byte_msgid[] =
+		      N_("%s %s differ: byte %s, line %s\n");
+		    char const *byte_message = _(byte_msgid);
+		    bool use_byte_message = (byte_message != byte_msgid
+					     || hard_locale_LC_MESSAGES);
+
+		    printf (use_byte_message ? byte_message : char_message,
+			    file[0], file[1], byte_num, line_num);
+		  }
+		else
+		  {
+		    unsigned char c0 = buf0[first_diff];
+		    unsigned char c1 = buf1[first_diff];
+		    char s0[5];
+		    char s1[5];
+		    sprintc (s0, c0);
+		    sprintc (s1, c1);
+		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+			    file[0], file[1], byte_num, line_num,
+			    c0, s0, c1, s1);
+		}
+	      }
+	      /* Fall through.  */
+	    case type_status:
+	      return EXIT_FAILURE;
+
+	    case type_all_diffs:
+	      do
+		{
+		  unsigned char c0 = buf0[first_diff];
+		  unsigned char c1 = buf1[first_diff];
+		  if (c0 != c1)
+		    {
+		      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *byte_num = offtostr (byte_number, byte_buf);
+		      if (!opt_print_bytes)
+			{
+			  /* See POSIX 1003.1-2001 for this format.  */
+			  printf ("%*s %3o %3o\n",
+				  offset_width, byte_num, c0, c1);
+			}
+		      else
+			{
+			  char s0[5];
+			  char s1[5];
+			  sprintc (s0, c0);
+			  sprintc (s1, c1);
+			  printf ("%*s %3o %-4s %3o %s\n",
+				  offset_width, byte_num, c0, s0, c1, s1);
+			}
+		    }
+		  byte_number++;
+		  first_diff++;
+		}
+	      while (first_diff < smaller);
+	      differing = -1;
+	      break;
+
+	    case type_no_stdout:
+	      differing = 1;
+	      break;
+	    }
+	}
+
+      if (read0 != read1)
+	{
+	  if (differing <= 0 && comparison_type != type_status)
+	    {
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      fprintf (stderr, _("cmp: EOF on %s\n"), file[read1 < read0]);
+	    }
+
+	  return EXIT_FAILURE;
+	}
+    }
+  while (differing <= 0 && read0 == buf_size);
+
+  return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ,
+   and count the number of '\n' occurrences in the common
+   part of P0 and P1.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.
+   Increment *COUNT by the count of '\n' occurrences.  */
+
+static size_t
+block_compare_and_count (word const *p0, word const *p1, off_t *count)
+{
+  word l;		/* One word from first buffer. */
+  word const *l0, *l1;	/* Pointers into each buffer. */
+  char const *c0, *c1;	/* Pointers for finding exact address. */
+  size_t cnt = 0;	/* Number of '\n' occurrences. */
+  word nnnn;		/* Newline, sizeof (word) times.  */
+  int i;
+
+  nnnn = 0;
+  for (i = 0; i < sizeof nnnn; i++)
+    nnnn = (nnnn << CHAR_BIT) | '\n';
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  (l = *l0) == *l1;  l0++, l1++)
+    {
+      l ^= nnnn;
+      for (i = 0; i < sizeof l; i++)
+	{
+	  unsigned char uc = l;
+	  cnt += ! uc;
+	  l >>= CHAR_BIT;
+	}
+    }
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    cnt += *c0 == '\n';
+
+  *count += cnt;
+  return c0 - (char const *) p0;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.  */
+
+static size_t
+block_compare (word const *p0, word const *p1)
+{
+  word const *l0, *l1;
+  char const *c0, *c1;
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  *l0 == *l1;  l0++, l1++)
+    continue;
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    continue;
+
+  return c0 - (char const *) p0;
+}
+
+/* Put into BUF the unsigned char C, making unprintable bytes
+   visible by quoting like cat -t does.  */
+
+static void
+sprintc (char *buf, unsigned char c)
+{
+  if (! isprint (c))
+    {
+      if (c >= 128)
+	{
+	  *buf++ = 'M';
+	  *buf++ = '-';
+	  c -= 128;
+	}
+      if (c < 32)
+	{
+	  *buf++ = '^';
+	  c += 64;
+	}
+      else if (c == 127)
+	{
+	  *buf++ = '^';
+	  c = '?';
+	}
+    }
+
+  *buf++ = c;
+  *buf = 0;
+}
+
+/* Position file F to ignore_initial[F] bytes from its initial position,
+   and yield its new position.  Don't try more than once.  */
+
+static off_t
+file_position (int f)
+{
+  static bool positioned[2];
+  static off_t position[2];
+
+  if (! positioned[f])
+    {
+      positioned[f] = true;
+      position[f] = lseek (file_desc[f], ignore_initial[f], SEEK_CUR);
+    }
+  return position[f];
+}
diff --git a/src/cmp.c.rej b/src/cmp.c.rej
new file mode 100644
index 0000000..6f2bec0
--- /dev/null
+++ b/src/cmp.c.rej
@@ -0,0 +1,76 @@
+--- src/cmp.c
++++ src/cmp.c
+@@ -115,7 +115,7 @@
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -134,7 +134,7 @@
+   if (! (e == LONGINT_OK
+ 	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+       || TYPE_MAXIMUM (off_t) < val)
+-    try_help ("invalid --ignore-initial value `%s'", arg);
++    try_help ("invalid --ignore-initial value '%s'", arg);
+   if (ignore_initial[f] < val)
+     ignore_initial[f] = val;
+ }
+@@ -185,7 +185,7 @@
+ 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+-	  _("If a FILE is `-' or missing, read standard input."),
++	  _("If a FILE is '-' or missing, read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -231,7 +231,7 @@
+ 	{
+ 	  uintmax_t n;
+ 	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+-	    try_help ("invalid --bytes value `%s'", optarg);
++	    try_help ("invalid --bytes value '%s'", optarg);
+ 	  if (n < bytes)
+ 	    bytes = n;
+ 	}
+@@ -257,7 +257,7 @@
+       }
+ 
+   if (optind == argc)
+-    try_help ("missing operand after `%s'", argv[argc - 1]);
++    try_help ("missing operand after '%s'", argv[argc - 1]);
+ 
+   file[0] = argv[optind++];
+   file[1] = optind < argc ? argv[optind++] : "-";
+@@ -269,7 +269,7 @@
+     }
+ 
+   if (optind < argc)
+-    try_help ("extra operand `%s'", argv[optind]);
++    try_help ("extra operand '%s'", argv[optind]);
+ 
+   for (f = 0; f < 2; f++)
+     {
+@@ -364,8 +364,8 @@
+   return exit_status;
+ }
+ 
+-/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
+-   using `buffer[0]' and `buffer[1]'.
++/* Compare the two files already open on 'file_desc[0]' and 'file_desc[1]',
++   using 'buffer[0]' and 'buffer[1]'.
+    Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+    >1 if error.  */
+ 
+@@ -377,7 +377,7 @@
+   uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+   size_t read0, read1;		/* Number of bytes read from each file. */
+   size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+-  size_t smaller;		/* The lesser of `read0' and `read1'. */
++  size_t smaller;		/* The lesser of 'read0' and 'read1'. */
+   word *buffer0 = buffer[0];
+   word *buffer1 = buffer[1];
+   char *buf0 = (char *) buffer0;
diff --git a/src/diff.c.orig b/src/diff.c.orig
new file mode 100644
index 0000000..9b0098c
--- /dev/null
+++ b/src/diff.c.orig
@@ -0,0 +1,1330 @@
+/* diff - compare files line by line
+
+   Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define GDIFF_MAIN
+#include "diff.h"
+#include <assert.h>
+#include "paths.h"
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exclude.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <fnmatch.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <prepargs.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <stat-time.h>
+#include <timespec.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff"
+
+#define AUTHORS \
+  proper_name ("Paul Eggert"), \
+  proper_name ("Mike Haertel"), \
+  proper_name ("David Hayes"), \
+  proper_name ("Richard Stallman"), \
+  proper_name ("Len Tower")
+
+#ifndef GUTTER_WIDTH_MINIMUM
+# define GUTTER_WIDTH_MINIMUM 3
+#endif
+
+struct regexp_list
+{
+  char *regexps;	/* chars representing disjunction of the regexps */
+  size_t len;		/* chars used in 'regexps' */
+  size_t size;		/* size malloc'ed for 'regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does 'regexps' represent a disjunction?  */
+  struct re_pattern_buffer *buf;
+};
+
+static int compare_files (struct comparison const *, char const *, char const *);
+static void add_regexp (struct regexp_list *, char const *);
+static void summarize_regexp_list (struct regexp_list *);
+static void specify_style (enum output_style);
+static void specify_value (char const **, char const *, char const *);
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void check_stdout (void);
+static void usage (void);
+
+/* If comparing directories, compare their common subdirectories
+   recursively.  */
+static bool recursive;
+
+/* In context diffs, show previous lines that match these regexps.  */
+static struct regexp_list function_regexp_list;
+
+/* Ignore changes affecting only lines that match these regexps.  */
+static struct regexp_list ignore_regexp_list;
+
+#if O_BINARY
+/* Use binary I/O when reading and writing data (--binary).
+   On POSIX hosts, this has no effect.  */
+static bool binary;
+#else
+enum { binary = true };
+#endif
+
+/* When comparing directories, if a file appears only in one
+   directory, treat it as present but empty in the other (-N).
+   Then 'patch' would create the file with appropriate contents.  */
+static bool new_file;
+
+/* When comparing directories, if a file appears only in the second
+   directory of the two, treat it as present but empty in the other
+   (--unidirectional-new-file).
+   Then 'patch' would create the file with appropriate contents.  */
+static bool unidirectional_new_file;
+
+/* Report files compared that are the same (-s).
+   Normally nothing is output when that happens.  */
+static bool report_identical_files;
+
+static char const shortopts[] =
+"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y";
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  BINARY_OPTION = CHAR_MAX + 1,
+  FROM_FILE_OPTION,
+  HELP_OPTION,
+  HORIZON_LINES_OPTION,
+  IGNORE_FILE_NAME_CASE_OPTION,
+  INHIBIT_HUNK_MERGE_OPTION,
+  LEFT_COLUMN_OPTION,
+  LINE_FORMAT_OPTION,
+  NO_IGNORE_FILE_NAME_CASE_OPTION,
+  NORMAL_OPTION,
+  SDIFF_MERGE_ASSIST_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  SUPPRESS_BLANK_EMPTY_OPTION,
+  SUPPRESS_COMMON_LINES_OPTION,
+  TABSIZE_OPTION,
+  TO_FILE_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_LINE_FORMAT_OPTION,
+  OLD_LINE_FORMAT_OPTION,
+  NEW_LINE_FORMAT_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_GROUP_FORMAT_OPTION,
+  OLD_GROUP_FORMAT_OPTION,
+  NEW_GROUP_FORMAT_OPTION,
+  CHANGED_GROUP_FORMAT_OPTION
+};
+
+static char const group_format_option[][sizeof "--unchanged-group-format"] =
+  {
+    "--unchanged-group-format",
+    "--old-group-format",
+    "--new-group-format",
+    "--changed-group-format"
+  };
+
+static char const line_format_option[][sizeof "--unchanged-line-format"] =
+  {
+    "--unchanged-line-format",
+    "--old-line-format",
+    "--new-line-format"
+  };
+
+static struct option const longopts[] =
+{
+  {"binary", 0, 0, BINARY_OPTION},
+  {"brief", 0, 0, 'q'},
+  {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+  {"context", 2, 0, 'C'},
+  {"ed", 0, 0, 'e'},
+  {"exclude", 1, 0, 'x'},
+  {"exclude-from", 1, 0, 'X'},
+  {"expand-tabs", 0, 0, 't'},
+  {"forward-ed", 0, 0, 'f'},
+  {"from-file", 1, 0, FROM_FILE_OPTION},
+  {"help", 0, 0, HELP_OPTION},
+  {"horizon-lines", 1, 0, HORIZON_LINES_OPTION},
+  {"ifdef", 1, 0, 'D'},
+  {"ignore-all-space", 0, 0, 'w'},
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-file-name-case", 0, 0, IGNORE_FILE_NAME_CASE_OPTION},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"left-column", 0, 0, LEFT_COLUMN_OPTION},
+  {"line-format", 1, 0, LINE_FORMAT_OPTION},
+  {"minimal", 0, 0, 'd'},
+  {"new-file", 0, 0, 'N'},
+  {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+  {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+  {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+  {"normal", 0, 0, NORMAL_OPTION},
+  {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+  {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+  {"paginate", 0, 0, 'l'},
+  {"rcs", 0, 0, 'n'},
+  {"recursive", 0, 0, 'r'},
+  {"report-identical-files", 0, 0, 's'},
+  {"sdiff-merge-assist", 0, 0, SDIFF_MERGE_ASSIST_OPTION},
+  {"show-c-function", 0, 0, 'p'},
+  {"show-function-line", 1, 0, 'F'},
+  {"side-by-side", 0, 0, 'y'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"starting-file", 1, 0, 'S'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-blank-empty", 0, 0, SUPPRESS_BLANK_EMPTY_OPTION},
+  {"suppress-common-lines", 0, 0, SUPPRESS_COMMON_LINES_OPTION},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"to-file", 1, 0, TO_FILE_OPTION},
+  {"unchanged-group-format", 1, 0, UNCHANGED_GROUP_FORMAT_OPTION},
+  {"unchanged-line-format", 1, 0, UNCHANGED_LINE_FORMAT_OPTION},
+  {"unidirectional-new-file", 0, 0, 'P'},
+  {"unified", 2, 0, 'U'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'W'},
+  {0, 0, 0, 0}
+};
+
+/* Return a string containing the command options with which diff was invoked.
+   Spaces appear between what were separate ARGV-elements.
+   There is a space at the beginning but none at the end.
+   If there were no options, the result is an empty string.
+
+   Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,
+   the length of that vector.  */
+
+static char *
+option_list (char **optionvec, int count)
+{
+  int i;
+  size_t size = 1;
+  char *result;
+  char *p;
+
+  for (i = 0; i < count; i++)
+    size += 1 + shell_quote_length (optionvec[i]);
+
+  p = result = xmalloc (size);
+
+  for (i = 0; i < count; i++)
+    {
+      *p++ = ' ';
+      p = shell_quote_copy (p, optionvec[i]);
+    }
+
+  *p = '\0';
+  return result;
+}
+
+
+/* Return an option value suitable for add_exclude.  */
+
+static int
+exclude_options (void)
+{
+  return EXCLUDE_WILDCARDS | (ignore_file_name_case ? FNM_CASEFOLD : 0);
+}
+
+int
+main (int argc, char **argv)
+{
+  int exit_status = EXIT_SUCCESS;
+  int c;
+  int i;
+  int prev = -1;
+  lin ocontext = -1;
+  bool explicit_context = false;
+  size_t width = 0;
+  bool show_c_function = false;
+  char const *from_file = NULL;
+  char const *to_file = NULL;
+  uintmax_t numval;
+  char *numend;
+
+  /* Do our initializations.  */
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+  function_regexp_list.buf = &function_regexp;
+  ignore_regexp_list.buf = &ignore_regexp;
+  re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+  excluded = new_exclude ();
+
+  /* Decode the options.  */
+
+  while ((c = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
+    {
+      switch (c)
+	{
+	case 0:
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (! ISDIGIT (prev))
+	    ocontext = c - '0';
+	  else if (LIN_MAX / 10 < ocontext
+		   || ((ocontext = 10 * ocontext + c - '0') < 0))
+	    ocontext = LIN_MAX;
+	  break;
+
+	case 'a':
+	  text = true;
+	  break;
+
+	case 'b':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space = IGNORE_SPACE_CHANGE;
+	  break;
+
+	case 'B':
+	  ignore_blank_lines = true;
+	  break;
+
+	case 'C':
+	case 'U':
+	  {
+	    if (optarg)
+	      {
+		numval = strtoumax (optarg, &numend, 10);
+		if (*numend)
+		  try_help ("invalid context length '%s'", optarg);
+		if (LIN_MAX < numval)
+		  numval = LIN_MAX;
+	      }
+	    else
+	      numval = 3;
+
+	    specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
+	    if (context < numval)
+	      context = numval;
+	    explicit_context = true;
+	  }
+	  break;
+
+	case 'c':
+	  specify_style (OUTPUT_CONTEXT);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'd':
+	  minimal = true;
+	  break;
+
+	case 'D':
+	  specify_style (OUTPUT_IFDEF);
+	  {
+	    static char const C_ifdef_group_formats[] =
+	      "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
+	    char *b = xmalloc (sizeof C_ifdef_group_formats
+			       + 7 * strlen (optarg) - 14 /* 7*"%s" */
+			       - 8 /* 5*"%%" + 3*"%c" */);
+	    sprintf (b, C_ifdef_group_formats,
+		     0,
+		     optarg, optarg, 0,
+		     optarg, optarg, 0,
+		     optarg, optarg, optarg);
+	    for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
+	      {
+		specify_value (&group_format[i], b, "-D");
+		b += strlen (b) + 1;
+	      }
+	  }
+	  break;
+
+	case 'e':
+	  specify_style (OUTPUT_ED);
+	  break;
+
+	case 'E':
+	  if (ignore_white_space < IGNORE_TAB_EXPANSION)
+	    ignore_white_space = IGNORE_TAB_EXPANSION;
+	  break;
+
+	case 'f':
+	  specify_style (OUTPUT_FORWARD_ED);
+	  break;
+
+	case 'F':
+	  add_regexp (&function_regexp_list, optarg);
+	  break;
+
+	case 'h':
+	  /* Split the files into chunks for faster processing.
+	     Usually does not change the result.
+
+	     This currently has no effect.  */
+	  break;
+
+	case 'H':
+	  speed_large_files = true;
+	  break;
+
+	case 'i':
+	  ignore_case = true;
+	  break;
+
+	case 'I':
+	  add_regexp (&ignore_regexp_list, optarg);
+	  break;
+
+	case 'l':
+	  if (!pr_program[0])
+	    try_help ("pagination not supported on this host", NULL);
+	  paginate = true;
+#ifdef SIGCHLD
+	  /* Pagination requires forking and waiting, and
+	     System V fork+wait does not work if SIGCHLD is ignored.  */
+	  signal (SIGCHLD, SIG_DFL);
+#endif
+	  break;
+
+	case 'L':
+	  if (!file_label[0])
+	    file_label[0] = optarg;
+	  else if (!file_label[1])
+	    file_label[1] = optarg;
+	  else
+	    fatal ("too many file label options");
+	  break;
+
+	case 'n':
+	  specify_style (OUTPUT_RCS);
+	  break;
+
+	case 'N':
+	  new_file = true;
+	  break;
+
+	case 'p':
+	  show_c_function = true;
+	  add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
+	  break;
+
+	case 'P':
+	  unidirectional_new_file = true;
+	  break;
+
+	case 'q':
+	  brief = true;
+	  break;
+
+	case 'r':
+	  recursive = true;
+	  break;
+
+	case 's':
+	  report_identical_files = true;
+	  break;
+
+	case 'S':
+	  specify_value (&starting_file, optarg, "-S");
+	  break;
+
+	case 't':
+	  expand_tabs = true;
+	  break;
+
+	case 'T':
+	  initial_tab = true;
+	  break;
+
+	case 'u':
+	  specify_style (OUTPUT_UNIFIED);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  ignore_white_space = IGNORE_ALL_SPACE;
+	  break;
+
+	case 'x':
+	  add_exclude (excluded, optarg, exclude_options ());
+	  break;
+
+	case 'X':
+	  if (add_exclude_file (add_exclude, excluded, optarg,
+				exclude_options (), '\n'))
+	    pfatal_with_name (optarg);
+	  break;
+
+	case 'y':
+	  specify_style (OUTPUT_SDIFF);
+	  break;
+
+	case 'W':
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid width '%s'", optarg);
+	  if (width != numval)
+	    {
+	      if (width)
+		fatal ("conflicting width options");
+	      width = numval;
+	    }
+	  break;
+
+	case BINARY_OPTION:
+#if O_BINARY
+	  binary = true;
+	  if (! isatty (STDOUT_FILENO))
+	    xfreopen (NULL, "wb", stdout);
+#endif
+	  break;
+
+	case FROM_FILE_OPTION:
+	  specify_value (&from_file, optarg, "--from-file");
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case HORIZON_LINES_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (*numend)
+	    try_help ("invalid horizon length '%s'", optarg);
+	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+	  break;
+
+	case IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = true;
+	  break;
+
+	case INHIBIT_HUNK_MERGE_OPTION:
+	  /* This option is obsolete, but accept it for backward
+             compatibility.  */
+	  break;
+
+	case LEFT_COLUMN_OPTION:
+	  left_column = true;
+	  break;
+
+	case LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	    specify_value (&line_format[i], optarg, "--line-format");
+	  break;
+
+	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = false;
+	  break;
+
+	case NORMAL_OPTION:
+	  specify_style (OUTPUT_NORMAL);
+	  break;
+
+	case SDIFF_MERGE_ASSIST_OPTION:
+	  specify_style (OUTPUT_SDIFF);
+	  sdiff_merge_assist = true;
+	  break;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+
+	case SUPPRESS_BLANK_EMPTY_OPTION:
+	  suppress_blank_empty = true;
+	  break;
+
+	case SUPPRESS_COMMON_LINES_OPTION:
+	  suppress_common_lines = true;
+	  break;
+
+	case TABSIZE_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid tabsize '%s'", optarg);
+	  if (tabsize != numval)
+	    {
+	      if (tabsize)
+		fatal ("conflicting tabsize options");
+	      tabsize = numval;
+	    }
+	  break;
+
+	case TO_FILE_OPTION:
+	  specify_value (&to_file, optarg, "--to-file");
+	  break;
+
+	case UNCHANGED_LINE_FORMAT_OPTION:
+	case OLD_LINE_FORMAT_OPTION:
+	case NEW_LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_LINE_FORMAT_OPTION;
+	  specify_value (&line_format[c], optarg, line_format_option[c]);
+	  break;
+
+	case UNCHANGED_GROUP_FORMAT_OPTION:
+	case OLD_GROUP_FORMAT_OPTION:
+	case NEW_GROUP_FORMAT_OPTION:
+	case CHANGED_GROUP_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_GROUP_FORMAT_OPTION;
+	  specify_value (&group_format[c], optarg, group_format_option[c]);
+	  break;
+
+	default:
+	  try_help (NULL, NULL);
+	}
+      prev = c;
+    }
+
+  if (output_style == OUTPUT_UNSPECIFIED)
+    {
+      if (show_c_function)
+	{
+	  specify_style (OUTPUT_CONTEXT);
+	  if (ocontext < 0)
+	    context = 3;
+	}
+      else
+	specify_style (OUTPUT_NORMAL);
+    }
+
+  if (output_style != OUTPUT_CONTEXT || hard_locale (LC_TIME))
+    {
+#if (defined STAT_TIMESPEC || defined STAT_TIMESPEC_NS \
+     || defined HAVE_STRUCT_STAT_ST_SPARE1)
+      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
+#else
+      time_format = "%Y-%m-%d %H:%M:%S %z";
+#endif
+    }
+  else
+    {
+      /* See POSIX 1003.1-2001 for this format.  */
+      time_format = "%a %b %e %T %Y";
+    }
+
+  if (0 <= ocontext
+      && (output_style == OUTPUT_CONTEXT
+	  || output_style == OUTPUT_UNIFIED)
+      && (context < ocontext
+	  || (ocontext < context && ! explicit_context)))
+    context = ocontext;
+
+  if (! tabsize)
+    tabsize = 8;
+  if (! width)
+    width = 130;
+
+  {
+    /* Maximize first the half line width, and then the gutter width,
+       according to the following constraints:
+
+	1.  Two half lines plus a gutter must fit in a line.
+	2.  If the half line width is nonzero:
+	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
+	    b.  If tabs are not expanded to spaces,
+		a half line plus a gutter is an integral number of tabs,
+		so that tabs in the right column line up.  */
+
+    intmax_t t = expand_tabs ? 1 : tabsize;
+    intmax_t w = width;
+    intmax_t off = (w + t + GUTTER_WIDTH_MINIMUM) / (2 * t)  *  t;
+    sdiff_half_width = MAX (0, MIN (off - GUTTER_WIDTH_MINIMUM, w - off)),
+    sdiff_column2_offset = sdiff_half_width ? off : w;
+  }
+
+  /* Make the horizon at least as large as the context, so that
+     shift_boundaries has more freedom to shift the first and last hunks.  */
+  if (horizon_lines < context)
+    horizon_lines = context;
+
+  summarize_regexp_list (&function_regexp_list);
+  summarize_regexp_list (&ignore_regexp_list);
+
+  if (output_style == OUTPUT_IFDEF)
+    {
+      for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	if (!line_format[i])
+	  line_format[i] = "%l\n";
+      if (!group_format[OLD])
+	group_format[OLD]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%<";
+      if (!group_format[NEW])
+	group_format[NEW]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%>";
+      if (!group_format[UNCHANGED])
+	group_format[UNCHANGED] = "%=";
+      if (!group_format[CHANGED])
+	group_format[CHANGED] = concat (group_format[OLD],
+					group_format[NEW], "");
+    }
+
+  no_diff_means_no_output =
+    (output_style == OUTPUT_IFDEF ?
+      (!*group_format[UNCHANGED]
+       || (STREQ (group_format[UNCHANGED], "%=")
+	   && !*line_format[UNCHANGED]))
+     : (output_style != OUTPUT_SDIFF) | suppress_common_lines);
+
+  files_can_be_treated_as_binary =
+    (brief & binary
+     & ~ (ignore_blank_lines | ignore_case | strip_trailing_cr
+	  | (ignore_regexp_list.regexps || ignore_white_space)));
+
+  switch_string = option_list (argv + 1, optind - 1);
+
+  if (from_file)
+    {
+      if (to_file)
+	fatal ("--from-file and --to-file both specified");
+      else
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, from_file, argv[optind]);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+    }
+  else
+    {
+      if (to_file)
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, argv[optind], to_file);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+      else
+	{
+	  if (argc - optind != 2)
+	    {
+	      if (argc - optind < 2)
+		try_help ("missing operand after '%s'", argv[argc - 1]);
+	      else
+		try_help ("extra operand '%s'", argv[optind + 2]);
+	    }
+
+	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+	}
+    }
+
+  /* Print any messages that were saved up for last.  */
+  print_message_queue ();
+
+  check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Append to REGLIST the regexp PATTERN.  */
+
+static void
+add_regexp (struct regexp_list *reglist, char const *pattern)
+{
+  size_t patlen = strlen (pattern);
+  char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+
+  if (m != 0)
+    error (0, 0, "%s: %s", pattern, m);
+  else
+    {
+      char *regexps = reglist->regexps;
+      size_t len = reglist->len;
+      bool multiple_regexps = reglist->multiple_regexps = regexps != 0;
+      size_t newlen = reglist->len = len + 2 * multiple_regexps + patlen;
+      size_t size = reglist->size;
+
+      if (size <= newlen)
+	{
+	  if (!size)
+	    size = 1;
+
+	  do size *= 2;
+	  while (size <= newlen);
+
+	  reglist->size = size;
+	  reglist->regexps = regexps = xrealloc (regexps, size);
+	}
+      if (multiple_regexps)
+	{
+	  regexps[len++] = '\\';
+	  regexps[len++] = '|';
+	}
+      memcpy (regexps + len, pattern, patlen + 1);
+    }
+}
+
+/* Ensure that REGLIST represents the disjunction of its regexps.
+   This is done here, rather than earlier, to avoid O(N^2) behavior.  */
+
+static void
+summarize_regexp_list (struct regexp_list *reglist)
+{
+  if (reglist->regexps)
+    {
+      /* At least one regexp was specified.  Allocate a fastmap for it.  */
+      reglist->buf->fastmap = xmalloc (1 << CHAR_BIT);
+      if (reglist->multiple_regexps)
+	{
+	  /* Compile the disjunction of the regexps.
+	     (If just one regexp was specified, it is already compiled.)  */
+	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+					      reglist->buf);
+	  if (m)
+	    error (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+	}
+    }
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    pfatal_with_name (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("Compare files line by line."),
+  "",
+  N_("-i  --ignore-case  Ignore case differences in file contents."),
+  N_("--ignore-file-name-case  Ignore case when comparing file names."),
+  N_("--no-ignore-file-name-case  Consider case when comparing file names."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-w  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+#if O_BINARY
+  N_("--binary  Read and write data in binary mode."),
+#endif
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\
+-u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\
+  --label LABEL  Use LABEL instead of file name.\n\
+  -p  --show-c-function  Show which C function each change is in.\n\
+  -F RE  --show-function-line=RE  Show the most recent line matching RE."),
+  N_("-q  --brief  Output only whether files differ."),
+  N_("-e  --ed  Output an ed script."),
+  N_("--normal  Output a normal diff."),
+  N_("-n  --rcs  Output an RCS format diff."),
+  N_("-y  --side-by-side  Output in two columns.\n\
+  -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+  --left-column  Output only the left column of common lines.\n\
+  --suppress-common-lines  Do not output common lines."),
+  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
+  N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+  N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+  N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+  N_("  GFMT may contain:\n\
+    %<  lines from FILE1\n\
+    %>  lines from FILE2\n\
+    %=  lines common to FILE1 and FILE2\n\
+    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n\
+      LETTERs are as follows for new group, lower case for old group:\n\
+        F  first line number\n\
+        L  last line number\n\
+        N  number of lines = L-F+1\n\
+        E  F-1\n\
+        M  L+1"),
+  N_("  LFMT may contain:\n\
+    %L  contents of line\n\
+    %l  contents of line, excluding any trailing newline\n\
+    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+  N_("  Either GFMT or LFMT may contain:\n\
+    %%  %\n\
+    %c'C'  the single character C\n\
+    %c'\\OOO'  the character with octal code OOO"),
+  "",
+  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  N_("--suppress-blank-empty  Suppress space or tab before empty output lines."),
+  "",
+  N_("-r  --recursive  Recursively compare any subdirectories found."),
+  N_("-N  --new-file  Treat absent files as empty."),
+  N_("--unidirectional-new-file  Treat absent first files as empty."),
+  N_("-s  --report-identical-files  Report when two files are the same."),
+  N_("-x PAT  --exclude=PAT  Exclude files that match PAT."),
+  N_("-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."),
+  N_("-S FILE  --starting-file=FILE  Start with FILE when comparing directories."),
+  N_("--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."),
+  N_("--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."),
+  "",
+  N_("--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."),
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("--speed-large-files  Assume large files and many scattered small changes."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  "",
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+  N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+  N_("If a FILE is '-', read standard input."),
+  N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+
+  for (p = option_help_msgid;  *p;  p++)
+    {
+      if (!**p)
+	putchar ('\n');
+      else
+	{
+	  char const *msg = _(*p);
+	  char const *nl;
+	  while ((nl = strchr (msg, '\n')))
+	    {
+	      int msglen = nl + 1 - msg;
+	      printf ("  %.*s", msglen, msg);
+	      msg = nl + 1;
+	    }
+
+	  printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
+	}
+    }
+  emit_bug_reporting_address ();
+}
+
+/* Set VAR to VALUE, reporting an OPTION error if this is a
+   conflict.  */
+static void
+specify_value (char const **var, char const *value, char const *option)
+{
+  if (*var && strcmp (*var, value) != 0)
+    {
+      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+      try_help (NULL, NULL);
+    }
+  *var = value;
+}
+
+/* Set the output style to STYLE, diagnosing conflicts.  */
+static void
+specify_style (enum output_style style)
+{
+  if (output_style != style)
+    {
+      if (output_style != OUTPUT_UNSPECIFIED)
+	try_help ("conflicting output style options", NULL);
+      output_style = style;
+    }
+}
+
+/* Set the last-modified time of *ST to be the current time.  */
+
+static void
+set_mtime_to_now (struct stat *st)
+{
+#ifdef STAT_TIMESPEC
+  gettime (&STAT_TIMESPEC (st, st_mtim));
+#else
+  struct timespec t;
+  gettime (&t);
+  st->st_mtime = t.tv_sec;
+# if defined STAT_TIMESPEC_NS
+  STAT_TIMESPEC_NS (st, st_mtim) = t.tv_nsec;
+# elif defined HAVE_STRUCT_STAT_ST_SPARE1
+  st->st_spare1 = t.tv_nsec / 1000;
+# endif
+#endif
+}
+
+/* Compare two files (or dirs) with parent comparison PARENT
+   and names NAME0 and NAME1.
+   (If PARENT is null, then the first name is just NAME0, etc.)
+   This is self-contained; it opens the files and closes them.
+
+   Value is EXIT_SUCCESS if files are the same, EXIT_FAILURE if
+   different, EXIT_TROUBLE if there is a problem opening them.  */
+
+static int
+compare_files (struct comparison const *parent,
+	       char const *name0,
+	       char const *name1)
+{
+  struct comparison cmp;
+#define DIR_P(f) (S_ISDIR (cmp.file[f].stat.st_mode) != 0)
+  register int f;
+  int status = EXIT_SUCCESS;
+  bool same_files;
+  char *free0;
+  char *free1;
+
+  /* If this is directory comparison, perhaps we have a file
+     that exists only in one of the directories.
+     If so, just print a message to that effect.  */
+
+  if (! ((name0 && name1)
+	 || (unidirectional_new_file && name1)
+	 || new_file))
+    {
+      char const *name = name0 ? name0 : name1;
+      char const *dir = parent->file[!name0].name;
+
+      /* See POSIX 1003.1-2001 for this format.  */
+      message ("Only in %s: %s\n", dir, name);
+
+      /* Return EXIT_FAILURE so that diff_dirs will return
+	 EXIT_FAILURE ("some files differ").  */
+      return EXIT_FAILURE;
+    }
+
+  memset (cmp.file, 0, sizeof cmp.file);
+  cmp.parent = parent;
+
+  /* cmp.file[f].desc markers */
+#define NONEXISTENT (-1) /* nonexistent file */
+#define UNOPENED (-2) /* unopened file (e.g. directory) */
+#define ERRNO_ENCODE(errno) (-3 - (errno)) /* encoded errno value */
+
+#define ERRNO_DECODE(desc) (-3 - (desc)) /* inverse of ERRNO_ENCODE */
+
+  cmp.file[0].desc = name0 ? UNOPENED : NONEXISTENT;
+  cmp.file[1].desc = name1 ? UNOPENED : NONEXISTENT;
+
+  /* Now record the full name of each file, including nonexistent ones.  */
+
+  if (!name0)
+    name0 = name1;
+  if (!name1)
+    name1 = name0;
+
+  if (!parent)
+    {
+      free0 = NULL;
+      free1 = NULL;
+      cmp.file[0].name = name0;
+      cmp.file[1].name = name1;
+    }
+  else
+    {
+      cmp.file[0].name = free0
+	= dir_file_pathname (parent->file[0].name, name0);
+      cmp.file[1].name = free1
+	= dir_file_pathname (parent->file[1].name, name1);
+    }
+
+  /* Stat the files.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      if (cmp.file[f].desc != NONEXISTENT)
+	{
+	  if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
+	    {
+	      cmp.file[f].desc = cmp.file[0].desc;
+	      cmp.file[f].stat = cmp.file[0].stat;
+	    }
+	  else if (STREQ (cmp.file[f].name, "-"))
+	    {
+	      cmp.file[f].desc = STDIN_FILENO;
+	      if (O_BINARY && binary && ! isatty (STDIN_FILENO))
+		xfreopen (NULL, "rb", stdin);
+	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+		cmp.file[f].desc = ERRNO_ENCODE (errno);
+	      else
+		{
+		  if (S_ISREG (cmp.file[f].stat.st_mode))
+		    {
+		      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
+		      if (pos < 0)
+			cmp.file[f].desc = ERRNO_ENCODE (errno);
+		      else
+			cmp.file[f].stat.st_size =
+			  MAX (0, cmp.file[f].stat.st_size - pos);
+		    }
+
+		  /* POSIX 1003.1-2001 requires current time for
+		     stdin.  */
+		  set_mtime_to_now (&cmp.file[f].stat);
+		}
+	    }
+	  else if (stat (cmp.file[f].name, &cmp.file[f].stat) != 0)
+	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+	}
+    }
+
+  /* Mark files as nonexistent as needed for -N and -P, if they are
+     inaccessible empty regular files (the kind of files that 'patch'
+     creates to indicate nonexistent backups), or if they are
+     top-level files that do not exist but their counterparts do
+     exist.  */
+  for (f = 0; f < 2; f++)
+    if ((new_file || (f == 0 && unidirectional_new_file))
+	&& (cmp.file[f].desc == UNOPENED
+	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+	       && cmp.file[f].stat.st_size == 0)
+	    : (cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+	       && ! parent
+	       && cmp.file[1 - f].desc == UNOPENED)))
+      cmp.file[f].desc = NONEXISTENT;
+
+  for (f = 0; f < 2; f++)
+    if (cmp.file[f].desc == NONEXISTENT)
+      {
+	memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
+	cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
+      }
+
+  for (f = 0; f < 2; f++)
+    {
+      int e = ERRNO_DECODE (cmp.file[f].desc);
+      if (0 <= e)
+	{
+	  errno = e;
+	  perror_with_name (cmp.file[f].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status == EXIT_SUCCESS && ! parent && DIR_P (0) != DIR_P (1))
+    {
+      /* If one is a directory, and it was specified in the command line,
+	 use the file in that dir with the other file's basename.  */
+
+      int fnm_arg = DIR_P (0);
+      int dir_arg = 1 - fnm_arg;
+      char const *fnm = cmp.file[fnm_arg].name;
+      char const *dir = cmp.file[dir_arg].name;
+      char const *filename = cmp.file[dir_arg].name = free0
+	= dir_file_pathname (dir, last_component (fnm));
+
+      if (STREQ (fnm, "-"))
+	fatal ("cannot compare '-' to a directory");
+
+      if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+	{
+	  perror_with_name (filename);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status != EXIT_SUCCESS)
+    {
+      /* One of the files should exist but does not.  */
+    }
+  else if (cmp.file[0].desc == NONEXISTENT
+	   && cmp.file[1].desc == NONEXISTENT)
+    {
+      /* Neither file "exists", so there's nothing to compare.  */
+    }
+  else if ((same_files
+	    = (cmp.file[0].desc != NONEXISTENT
+	       && cmp.file[1].desc != NONEXISTENT
+	       && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
+	       && same_file_attributes (&cmp.file[0].stat,
+					&cmp.file[1].stat)))
+	   && no_diff_means_no_output)
+    {
+      /* The two named files are actually the same physical file.
+	 We know they are identical without actually reading them.  */
+    }
+  else if (DIR_P (0) & DIR_P (1))
+    {
+      if (output_style == OUTPUT_IFDEF)
+	fatal ("-D option not supported with directories");
+
+      /* If both are directories, compare the files in them.  */
+
+      if (parent && !recursive)
+	{
+	  /* But don't compare dir contents one level down
+	     unless -r was specified.
+	     See POSIX 1003.1-2001 for this format.  */
+	  message ("Common subdirectories: %s and %s\n",
+		   cmp.file[0].name, cmp.file[1].name);
+	}
+      else
+	status = diff_dirs (&cmp, compare_files);
+    }
+  else if ((DIR_P (0) | DIR_P (1))
+	   || (parent
+	       && (! S_ISREG (cmp.file[0].stat.st_mode)
+		   || ! S_ISREG (cmp.file[1].stat.st_mode))))
+    {
+      if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+	{
+	  /* We have a subdirectory that exists only in one directory.  */
+
+	  if ((DIR_P (0) | DIR_P (1))
+	      && recursive
+	      && (new_file
+		  || (unidirectional_new_file
+		      && cmp.file[0].desc == NONEXISTENT)))
+	    status = diff_dirs (&cmp, compare_files);
+	  else
+	    {
+	      char const *dir;
+
+	      /* PARENT must be non-NULL here.  */
+	      assert (parent);
+	      dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
+
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      message ("Only in %s: %s\n", dir, name0);
+
+	      status = EXIT_FAILURE;
+	    }
+	}
+      else
+	{
+	  /* We have two files that are not to be compared.  */
+
+	  /* See POSIX 1003.1-2001 for this format.  */
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (files_can_be_treated_as_binary
+	   && S_ISREG (cmp.file[0].stat.st_mode)
+	   && S_ISREG (cmp.file[1].stat.st_mode)
+	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size)
+    {
+      message ("Files %s and %s differ\n",
+	       file_label[0] ? file_label[0] : cmp.file[0].name,
+	       file_label[1] ? file_label[1] : cmp.file[1].name);
+      status = EXIT_FAILURE;
+    }
+  else
+    {
+      /* Both exist and neither is a directory.  */
+
+      /* Open the files and record their descriptors.  */
+
+      int oflags = O_RDONLY | (binary ? O_BINARY : 0);
+
+      if (cmp.file[0].desc == UNOPENED)
+	if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
+	  {
+	    perror_with_name (cmp.file[0].name);
+	    status = EXIT_TROUBLE;
+	  }
+      if (cmp.file[1].desc == UNOPENED)
+	{
+	  if (same_files)
+	    cmp.file[1].desc = cmp.file[0].desc;
+	  else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
+	    {
+	      perror_with_name (cmp.file[1].name);
+	      status = EXIT_TROUBLE;
+	    }
+	}
+
+      /* Compare the files, if no error was found.  */
+
+      if (status == EXIT_SUCCESS)
+	status = diff_2_files (&cmp);
+
+      /* Close the file descriptors.  */
+
+      if (0 <= cmp.file[0].desc && close (cmp.file[0].desc) != 0)
+	{
+	  perror_with_name (cmp.file[0].name);
+	  status = EXIT_TROUBLE;
+	}
+      if (0 <= cmp.file[1].desc && cmp.file[0].desc != cmp.file[1].desc
+	  && close (cmp.file[1].desc) != 0)
+	{
+	  perror_with_name (cmp.file[1].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  /* Now the comparison has been done, if no error prevented it,
+     and STATUS is the value this function will return.  */
+
+  if (status == EXIT_SUCCESS)
+    {
+      if (report_identical_files && !DIR_P (0))
+	message ("Files %s and %s are identical\n",
+		 file_label[0] ? file_label[0] : cmp.file[0].name,
+		 file_label[1] ? file_label[1] : cmp.file[1].name);
+    }
+  else
+    {
+      /* Flush stdout so that the user sees differences immediately.
+	 This can hurt performance, unfortunately.  */
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("standard output"));
+    }
+
+  free (free0);
+  free (free1);
+
+  return status;
+}
diff --git a/src/diff3.c.orig b/src/diff3.c.orig
new file mode 100644
index 0000000..5a31f72
--- /dev/null
+++ b/src/diff3.c.orig
@@ -0,0 +1,1747 @@
+/* diff3 - compare three files line by line
+
+   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff3"
+
+#define AUTHORS \
+  proper_name ("Randy Smith")
+
+/* Internal data structures and macros for the diff3 program; includes
+   data structures for both diff3 diffs and normal diffs.  */
+
+/* Different files within a three way diff.  */
+#define	FILE0	0
+#define	FILE1	1
+#define	FILE2	2
+
+/* A three way diff is built from two two-way diffs; the file which
+   the two two-way diffs share is:  */
+#define	FILEC	FILE2
+
+/* Different files within a two way diff.
+   FC is the common file, FO the other file.  */
+#define FO 0
+#define FC 1
+
+/* The ranges are indexed by */
+#define	RANGE_START	0
+#define	RANGE_END	1
+
+enum diff_type {
+  ERROR,			/* Should not be used */
+  ADD,				/* Two way diff add */
+  CHANGE,			/* Two way diff change */
+  DELETE,			/* Two way diff delete */
+  DIFF_ALL,			/* All three are different */
+  DIFF_1ST,			/* Only the first is different */
+  DIFF_2ND,			/* Only the second */
+  DIFF_3RD			/* Only the third */
+};
+
+/* Two way diff */
+struct diff_block {
+  lin ranges[2][2];		/* Ranges are inclusive */
+  char **lines[2];		/* The actual lines (may contain nulls) */
+  size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+  struct diff_block *next;
+};
+
+/* Three way diff */
+
+struct diff3_block {
+  enum diff_type correspond;	/* Type of diff */
+  lin ranges[3][2];		/* Ranges are inclusive */
+  char **lines[3];		/* The actual lines (may contain nulls) */
+  size_t *lengths[3];		/* Line lengths (including newlines, if any) */
+  struct diff3_block *next;
+};
+
+/* Access the ranges on a diff block.  */
+#define	D_LOWLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_START])
+#define	D_HIGHLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_END])
+#define	D_NUMLINES(diff, filenum)	\
+  (D_HIGHLINE (diff, filenum) - D_LOWLINE (diff, filenum) + 1)
+
+/* Access the line numbers in a file in a diff by relative line
+   numbers (i.e. line number within the diff itself).  Note that these
+   are lvalues and can be used for assignment.  */
+#define	D_RELNUM(diff, filenum, linenum)	\
+  ((diff)->lines[filenum][linenum])
+#define	D_RELLEN(diff, filenum, linenum)	\
+  ((diff)->lengths[filenum][linenum])
+
+/* And get at them directly, when that should be necessary.  */
+#define	D_LINEARRAY(diff, filenum)	\
+  ((diff)->lines[filenum])
+#define	D_LENARRAY(diff, filenum)	\
+  ((diff)->lengths[filenum])
+
+/* Next block.  */
+#define	D_NEXT(diff)	((diff)->next)
+
+/* Access the type of a diff3 block.  */
+#define	D3_TYPE(diff)	((diff)->correspond)
+
+/* Line mappings based on diffs.  The first maps off the top of the
+   diff, the second off of the bottom.  */
+#define	D_HIGH_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_HIGHLINE ((diff), (fromfile))			\
+   + D_HIGHLINE ((diff), (tofile)))
+
+#define	D_LOW_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_LOWLINE ((diff), (fromfile))			\
+   + D_LOWLINE ((diff), (tofile)))
+
+/* Options variables for flags set on command line.  */
+
+/* If nonzero, treat all files as text files, never as binary.  */
+static bool text;
+
+/* Remove trailing carriage returns from input.  */
+static bool strip_trailing_cr;
+
+/* If nonzero, write out an ed script instead of the standard diff3 format.  */
+static bool edscript;
+
+/* If nonzero, in the case of overlapping diffs (type DIFF_ALL),
+   preserve the lines which would normally be deleted from
+   file 1 with a special flagging mechanism.  */
+static bool flagging;
+
+/* Use a tab to align output lines (-T).  */
+static bool initial_tab;
+
+/* If nonzero, do not output information for overlapping diffs.  */
+static bool simple_only;
+
+/* If nonzero, do not output information for non-overlapping diffs.  */
+static bool overlap_only;
+
+/* If nonzero, show information for DIFF_2ND diffs.  */
+static bool show_2nd;
+
+/* If nonzero, include ':wq' at the end of the script
+   to write out the file being edited.   */
+static bool finalwrite;
+
+/* If nonzero, output a merged file.  */
+static bool merge;
+
+static char *read_diff (char const *, char const *, char **);
+static char *scan_diff_line (char *, char **, size_t *, char *, char);
+static enum diff_type process_diff_control (char **, struct diff_block *);
+static bool compare_line_list (char * const[], size_t const[], char * const[], size_t const[], lin);
+static bool copy_stringlist (char * const[], size_t const[], char *[], size_t[], lin);
+static bool output_diff3_edscript (FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static bool output_diff3_merge (FILE *, FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static struct diff3_block *create_diff3_block (lin, lin, lin, lin, lin, lin);
+static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+static struct diff_block *process_diff (char const *, char const *, struct diff_block **);
+static void check_stdout (void);
+static void fatal (char const *) __attribute__((noreturn));
+static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+static void perror_with_exit (char const *) __attribute__((noreturn));
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void usage (void);
+
+static char const *diff_program = DEFAULT_DIFF_PROGRAM;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"easy-only", 0, 0, '3'},
+  {"ed", 0, 0, 'e'},
+  {"help", 0, 0, HELP_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"merge", 0, 0, 'm'},
+  {"overlap-only", 0, 0, 'x'},
+  {"show-all", 0, 0, 'A'},
+  {"show-overlap", 0, 0, 'E'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {0, 0, 0, 0}
+};
+
+int
+main (int argc, char **argv)
+{
+  int c, i;
+  int common;
+  int mapping[3];
+  int rev_mapping[3];
+  int incompat = 0;
+  bool conflicts_found;
+  struct diff_block *thread0, *thread1, *last_block;
+  struct diff3_block *diff3;
+  int tag_count = 0;
+  char *tag_strings[3];
+  char *commonname;
+  char **file;
+  struct stat statb;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  while ((c = getopt_long (argc, argv, "aeimvx3AEL:TX", longopts, 0)) != -1)
+    {
+      switch (c)
+	{
+	case 'a':
+	  text = true;
+	  break;
+	case 'A':
+	  show_2nd = true;
+	  flagging = true;
+	  incompat++;
+	  break;
+	case 'x':
+	  overlap_only = true;
+	  incompat++;
+	  break;
+	case '3':
+	  simple_only = true;
+	  incompat++;
+	  break;
+	case 'i':
+	  finalwrite = true;
+	  break;
+	case 'm':
+	  merge = true;
+	  break;
+	case 'X':
+	  overlap_only = true;
+	  /* Fall through.  */
+	case 'E':
+	  flagging = true;
+	  /* Fall through.  */
+	case 'e':
+	  incompat++;
+	  break;
+	case 'T':
+	  initial_tab = true;
+	  break;
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case DIFF_PROGRAM_OPTION:
+	  diff_program = optarg;
+	  break;
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case 'L':
+	  /* Handle up to three -L options.  */
+	  if (tag_count < 3)
+	    {
+	      tag_strings[tag_count++] = optarg;
+	      break;
+	    }
+	  try_help ("too many file label options", 0);
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  edscript = incompat & ~merge;  /* -AeExX3 without -m implies ed script.  */
+  show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+  flagging |= ~incompat & merge;
+
+  if (incompat > 1  /* Ensure at most one of -AeExX3.  */
+      || finalwrite & merge /* -i -m would rewrite input file.  */
+      || (tag_count && ! flagging)) /* -L requires one of -AEX.  */
+    try_help ("incompatible options", 0);
+
+  if (argc - optind != 3)
+    {
+      if (argc - optind < 3)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 3]);
+    }
+
+  file = &argv[optind];
+
+  for (i = tag_count; i < 3; i++)
+    tag_strings[i] = file[i];
+
+  /* Always compare file1 to file2, even if file2 is "-".
+     This is needed for -mAeExX3.  Using the file0 as
+     the common file would produce wrong results, because if the
+     file0-file1 diffs didn't line up with the file0-file2 diffs
+     (which is entirely possible since we don't use diff's -n option),
+     diff3 might report phantom changes from file1 to file2.
+
+     Also, try to compare file0 to file1, because this is where
+     changes are expected to come from.  Diffing between these pairs
+     of files is more likely to avoid phantom changes from file0 to file1.
+
+     Historically, the default common file was file2, so some older
+     applications (e.g. Emacs ediff) used file2 as the ancestor.  So,
+     for compatibility, if this is a 3-way diff (not a merge or
+     edscript), prefer file2 as the common file.  */
+
+  common = 2 - (edscript | merge);
+
+  if (STREQ (file[common], "-"))
+    {
+      /* Sigh.  We've got standard input as the common file.  We can't
+	 call diff twice on stdin.  Use the other arg as the common
+	 file instead.  */
+      common = 3 - common;
+      if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+	fatal ("'-' specified for more than one input file");
+    }
+
+  mapping[0] = 0;
+  mapping[1] = 3 - common;
+  mapping[2] = common;
+
+  for (i = 0; i < 3; i++)
+    rev_mapping[mapping[i]] = i;
+
+  for (i = 0; i < 3; i++)
+    if (strcmp (file[i], "-") != 0)
+      {
+	if (stat (file[i], &statb) < 0)
+	  perror_with_exit (file[i]);
+	else if (S_ISDIR (statb.st_mode))
+	  error (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+      }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  /* Invoke diff twice on two pairs of input files, combine the two
+     diffs, and output them.  */
+
+  commonname = file[rev_mapping[FILEC]];
+  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block);
+  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block);
+  diff3 = make_3way_diff (thread0, thread1);
+  if (edscript)
+    conflicts_found
+      = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+			       tag_strings[0], tag_strings[1], tag_strings[2]);
+  else if (merge)
+    {
+      xfreopen (file[rev_mapping[FILE0]], "r", stdin);
+      conflicts_found
+	= output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
+			      tag_strings[0], tag_strings[1], tag_strings[2]);
+      if (ferror (stdin))
+	fatal ("read failed");
+    }
+  else
+    {
+      output_diff3 (stdout, diff3, mapping, rev_mapping);
+      conflicts_found = false;
+    }
+
+  check_stdout ();
+  exit (conflicts_found);
+  return conflicts_found;
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_with_exit (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE."),
+  N_("-E  --show-overlap  Output unmerged changes, bracketing conflicts."),
+  N_("-A  --show-all  Output all changes, bracketing conflicts."),
+  N_("-x  --overlap-only  Output overlapping changes."),
+  N_("-X  Output overlapping changes, bracketing them."),
+  N_("-3  --easy-only  Output unmerged nonoverlapping changes."),
+  "",
+  N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+  N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+  N_("-i  Append 'w' and 'q' commands to ed scripts."),
+  N_("-a  --text  Treat all files as text."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare three files line by line."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Combine the two diffs together into one.
+   Here is the algorithm:
+
+     File2 is shared in common between the two diffs.
+     Diff02 is the diff between 0 and 2.
+     Diff12 is the diff between 1 and 2.
+
+	1) Find the range for the first block in File2.
+	    a) Take the lowest of the two ranges (in File2) in the two
+	       current blocks (one from each diff) as being the low
+	       water mark.  Assign the upper end of this block as
+	       being the high water mark and move the current block up
+	       one.  Mark the block just moved over as to be used.
+	    b) Check the next block in the diff that the high water
+	       mark is *not* from.
+
+	       *If* the high water mark is above
+	       the low end of the range in that block,
+
+		   mark that block as to be used and move the current
+		   block up.  Set the high water mark to the max of
+		   the high end of this block and the current.  Repeat b.
+
+	 2) Find the corresponding ranges in File0 (from the blocks
+	    in diff02; line per line outside of diffs) and in File1.
+	    Create a diff3_block, reserving space as indicated by the ranges.
+
+	 3) Copy all of the pointers for file2 in.  At least for now,
+	    do memcmp's between corresponding strings in the two diffs.
+
+	 4) Copy all of the pointers for file0 and 1 in.  Get what is
+	    needed from file2 (when there isn't a diff block, it's
+	    identical to file2 within the range between diff blocks).
+
+	 5) If the diff blocks used came from only one of the two
+	    strings of diffs, then that file (i.e. the one other than
+	    the common file in that diff) is the odd person out.  If
+	    diff blocks are used from both sets, check to see if files
+	    0 and 1 match:
+
+		Same number of lines?  If so, do a set of memcmp's (if
+	    a memcmp matches; copy the pointer over; it'll be easier
+	    later during comparisons).  If they match, 0 & 1 are the
+	    same.  If not, all three different.
+
+     Then do it again, until the blocks are exhausted.  */
+
+
+/* Make a three way diff (chain of diff3_block's) from two two way
+   diffs (chains of diff_block's).  Assume that each of the two diffs
+   passed are onto the same file (i.e. that each of the diffs were
+   made "to" the same file).  Return a three way diff pointer with
+   numbering FILE0 = the other file in diff02, FILE1 = the other file
+   in diff12, and FILEC = the common file.  */
+
+static struct diff3_block *
+make_3way_diff (struct diff_block *thread0, struct diff_block *thread1)
+{
+  /* Work on the two diffs passed to it as threads.  Thread number 0
+     is diff02, thread number 1 is diff12.  USING is the base of the
+     list of blocks to be used to construct each block of the three
+     way diff; if no blocks from a particular thread are to be used,
+     that element of USING is 0.  LAST_USING contains the last
+     elements on each of the using lists.
+
+     HIGH_WATER_MARK is the highest line number in the common file
+     described in any of the diffs in either of the USING lists.
+     HIGH_WATER_THREAD names the thread.  Similarly BASE_WATER_MARK
+     and BASE_WATER_THREAD describe the lowest line number in the
+     common file described in any of the diffs in either of the USING
+     lists.  HIGH_WATER_DIFF is the diff from which the
+     HIGH_WATER_MARK was taken.
+
+     HIGH_WATER_DIFF should always be equal to
+     LAST_USING[HIGH_WATER_THREAD].  OTHER_DIFF is the next diff to
+     check for higher water, and should always be equal to
+     CURRENT[HIGH_WATER_THREAD ^ 1].  OTHER_THREAD is the thread in
+     which the OTHER_DIFF is, and hence should always be equal to
+     HIGH_WATER_THREAD ^ 1.
+
+     LAST_DIFF is the last diff block produced by this routine, for
+     line correspondence purposes between that diff and the one
+     currently being worked on.  It is ZERO_DIFF before any blocks
+     have been created.  */
+
+  struct diff_block *using[2];
+  struct diff_block *last_using[2];
+  struct diff_block *current[2];
+
+  lin high_water_mark;
+
+  int high_water_thread;
+  int base_water_thread;
+  int other_thread;
+
+  struct diff_block *high_water_diff;
+  struct diff_block *other_diff;
+
+  struct diff3_block *result;
+  struct diff3_block *tmpblock;
+  struct diff3_block **result_end;
+
+  struct diff3_block const *last_diff3;
+
+  static struct diff3_block const zero_diff3;
+
+  /* Initialization */
+  result = 0;
+  result_end = &result;
+  current[0] = thread0; current[1] = thread1;
+  last_diff3 = &zero_diff3;
+
+  /* Sniff up the threads until we reach the end */
+
+  while (current[0] || current[1])
+    {
+      using[0] = using[1] = last_using[0] = last_using[1] = 0;
+
+      /* Setup low and high water threads, diffs, and marks.  */
+      if (!current[0])
+	base_water_thread = 1;
+      else if (!current[1])
+	base_water_thread = 0;
+      else
+	base_water_thread =
+	  (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
+
+      high_water_thread = base_water_thread;
+
+      high_water_diff = current[high_water_thread];
+
+      high_water_mark = D_HIGHLINE (high_water_diff, FC);
+
+      /* Make the diff you just got info from into the using class */
+      using[high_water_thread]
+	= last_using[high_water_thread]
+	= high_water_diff;
+      current[high_water_thread] = high_water_diff->next;
+      last_using[high_water_thread]->next = 0;
+
+      /* And mark the other diff */
+      other_thread = high_water_thread ^ 0x1;
+      other_diff = current[other_thread];
+
+      /* Shuffle up the ladder, checking the other diff to see if it
+	 needs to be incorporated.  */
+      while (other_diff
+	     && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
+	{
+
+	  /* Incorporate this diff into the using list.  Note that
+	     this doesn't take it off the current list */
+	  if (using[other_thread])
+	    last_using[other_thread]->next = other_diff;
+	  else
+	    using[other_thread] = other_diff;
+	  last_using[other_thread] = other_diff;
+
+	  /* Take it off the current list.  Note that this following
+	     code assumes that other_diff enters it equal to
+	     current[high_water_thread ^ 0x1] */
+	  current[other_thread] = current[other_thread]->next;
+	  other_diff->next = 0;
+
+	  /* Set the high_water stuff
+	     If this comparison is equal, then this is the last pass
+	     through this loop; since diff blocks within a given
+	     thread cannot overlap, the high_water_mark will be
+	     *below* the range_start of either of the next diffs.  */
+
+	  if (high_water_mark < D_HIGHLINE (other_diff, FC))
+	    {
+	      high_water_thread ^= 1;
+	      high_water_mark = D_HIGHLINE (other_diff, FC);
+	    }
+
+	  /* Set the other diff */
+	  other_thread = high_water_thread ^ 0x1;
+	  other_diff = current[other_thread];
+	}
+
+      /* The using lists contain a list of all of the blocks to be
+	 included in this diff3_block.  Create it.  */
+
+      tmpblock = using_to_diff3_block (using, last_using,
+				       base_water_thread, high_water_thread,
+				       last_diff3);
+
+      if (!tmpblock)
+	fatal ("internal error: screwup in format of diff blocks");
+
+      /* Put it on the list.  */
+      *result_end = tmpblock;
+      result_end = &tmpblock->next;
+
+      /* Set up corresponding lines correctly.  */
+      last_diff3 = tmpblock;
+    }
+  return result;
+}
+
+/* Take two lists of blocks (from two separate diff threads) and put
+   them together into one diff3 block.  Return a pointer to this diff3
+   block or 0 for failure.
+
+   All arguments besides using are for the convenience of the routine;
+   they could be derived from the using array.  LAST_USING is a pair
+   of pointers to the last blocks in the using structure.  LOW_THREAD
+   and HIGH_THREAD tell which threads contain the lowest and highest
+   line numbers for File0.  LAST_DIFF3 contains the last diff produced
+   in the calling routine.  This is used for lines mappings that
+   would still be identical to the state that diff ended in.
+
+   A distinction should be made in this routine between the two diffs
+   that are part of a normal two diff block, and the three diffs that
+   are part of a diff3_block.  */
+
+static struct diff3_block *
+using_to_diff3_block (struct diff_block *using[2],
+		      struct diff_block *last_using[2],
+		      int low_thread, int high_thread,
+		      struct diff3_block const *last_diff3)
+{
+  lin low[2], high[2];
+  struct diff3_block *result;
+  struct diff_block *ptr;
+  int d;
+  lin i;
+
+  /* Find the range in the common file.  */
+  lin lowc = D_LOWLINE (using[low_thread], FC);
+  lin highc = D_HIGHLINE (last_using[high_thread], FC);
+
+  /* Find the ranges in the other files.
+     If using[d] is null, that means that the file to which that diff
+     refers is equivalent to the common file over this range.  */
+
+  for (d = 0; d < 2; d++)
+    if (using[d])
+      {
+	low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
+	high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
+      }
+    else
+      {
+	low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
+	high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
+      }
+
+  /* Create a block with the appropriate sizes */
+  result = create_diff3_block (low[0], high[0], low[1], high[1], lowc, highc);
+
+  /* Copy information for the common file.
+     Return with a zero if any of the compares failed.  */
+
+  for (d = 0; d < 2; d++)
+    for (ptr = using[d]; ptr; ptr = D_NEXT (ptr))
+      {
+	lin result_offset = D_LOWLINE (ptr, FC) - lowc;
+
+	if (!copy_stringlist (D_LINEARRAY (ptr, FC),
+			      D_LENARRAY (ptr, FC),
+			      D_LINEARRAY (result, FILEC) + result_offset,
+			      D_LENARRAY (result, FILEC) + result_offset,
+			      D_NUMLINES (ptr, FC)))
+	  return 0;
+      }
+
+  /* Copy information for file d.  First deal with anything that might be
+     before the first diff.  */
+
+  for (d = 0; d < 2; d++)
+    {
+      struct diff_block *u = using[d];
+      lin lo = low[d], hi = high[d];
+
+      for (i = 0;
+	   i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
+	   i++)
+	{
+	  D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
+	  D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
+	}
+
+      for (ptr = u; ptr; ptr = D_NEXT (ptr))
+	{
+	  lin result_offset = D_LOWLINE (ptr, FO) - lo;
+	  lin linec;
+
+	  if (!copy_stringlist (D_LINEARRAY (ptr, FO),
+				D_LENARRAY (ptr, FO),
+				D_LINEARRAY (result, FILE0 + d) + result_offset,
+				D_LENARRAY (result, FILE0 + d) + result_offset,
+				D_NUMLINES (ptr, FO)))
+	    return 0;
+
+	  /* Catch the lines between here and the next diff */
+	  linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
+	  for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
+	       i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
+	       i++)
+	    {
+	      D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
+	      D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
+	      linec++;
+	    }
+	}
+    }
+
+  /* Set correspond */
+  if (!using[0])
+    D3_TYPE (result) = DIFF_2ND;
+  else if (!using[1])
+    D3_TYPE (result) = DIFF_1ST;
+  else
+    {
+      lin nl0 = D_NUMLINES (result, FILE0);
+      lin nl1 = D_NUMLINES (result, FILE1);
+
+      if (nl0 != nl1
+	  || !compare_line_list (D_LINEARRAY (result, FILE0),
+				 D_LENARRAY (result, FILE0),
+				 D_LINEARRAY (result, FILE1),
+				 D_LENARRAY (result, FILE1),
+				 nl0))
+	D3_TYPE (result) = DIFF_ALL;
+      else
+	D3_TYPE (result) = DIFF_3RD;
+    }
+
+  return result;
+}
+
+/* Copy pointers from a list of strings to a different list of
+   strings.  If a spot in the second list is already filled, make sure
+   that it is filled with the same string; if not, return false, the copy
+   incomplete.  Upon successful completion of the copy, return true.  */
+
+static bool
+copy_stringlist (char * const fromptrs[], size_t const fromlengths[],
+		 char *toptrs[], size_t tolengths[],
+		 lin copynum)
+{
+  register char * const *f = fromptrs;
+  register char **t = toptrs;
+  register size_t const *fl = fromlengths;
+  register size_t *tl = tolengths;
+
+  while (copynum--)
+    {
+      if (*t)
+	{
+	  if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
+	    return false;
+	}
+      else
+	{
+	  *t = *f;
+	  *tl = *fl;
+	}
+
+      t++; f++; tl++; fl++;
+    }
+
+  return true;
+}
+
+/* Create a diff3_block, with ranges as specified in the arguments.
+   Allocate the arrays for the various pointers (and zero them) based
+   on the arguments passed.  Return the block as a result.  */
+
+static struct diff3_block *
+create_diff3_block (lin low0, lin high0,
+		    lin low1, lin high1,
+		    lin low2, lin high2)
+{
+  struct diff3_block *result = xmalloc (sizeof *result);
+  lin numlines;
+
+  D3_TYPE (result) = ERROR;
+  D_NEXT (result) = 0;
+
+  /* Assign ranges */
+  D_LOWLINE (result, FILE0) = low0;
+  D_HIGHLINE (result, FILE0) = high0;
+  D_LOWLINE (result, FILE1) = low1;
+  D_HIGHLINE (result, FILE1) = high1;
+  D_LOWLINE (result, FILE2) = low2;
+  D_HIGHLINE (result, FILE2) = high2;
+
+  /* Allocate and zero space */
+  numlines = D_NUMLINES (result, FILE0);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE0) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE0) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE0) = 0;
+      D_LENARRAY (result, FILE0) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE1);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE1) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE1) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE1) = 0;
+      D_LENARRAY (result, FILE1) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE2);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE2) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE2) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE2) = 0;
+      D_LENARRAY (result, FILE2) = 0;
+    }
+
+  /* Return */
+  return result;
+}
+
+/* Compare two lists of lines of text.
+   Return 1 if they are equivalent, 0 if not.  */
+
+static bool
+compare_line_list (char * const list1[], size_t const lengths1[],
+		   char * const list2[], size_t const lengths2[],
+		   lin nl)
+{
+  char * const *l1 = list1;
+  char * const *l2 = list2;
+  size_t const *lgths1 = lengths1;
+  size_t const *lgths2 = lengths2;
+
+  while (nl--)
+    if (!*l1 || !*l2 || *lgths1 != *lgths2++
+	|| memcmp (*l1++, *l2++, *lgths1++) != 0)
+      return false;
+  return true;
+}
+
+/* Input and parse two way diffs.  */
+
+static struct diff_block *
+process_diff (char const *filea,
+	      char const *fileb,
+	      struct diff_block **last_block)
+{
+  char *diff_contents;
+  char *diff_limit;
+  char *scan_diff;
+  enum diff_type dt;
+  lin i;
+  struct diff_block *block_list;
+  struct diff_block **block_list_end = &block_list;
+  struct diff_block *bptr IF_LINT (= NULL);
+  size_t too_many_lines = (PTRDIFF_MAX
+			   / MIN (sizeof *bptr->lines[1],
+				  sizeof *bptr->lengths[1]));
+
+  diff_limit = read_diff (filea, fileb, &diff_contents);
+  scan_diff = diff_contents;
+
+  while (scan_diff < diff_limit)
+    {
+      bptr = xmalloc (sizeof *bptr);
+      bptr->lines[0] = bptr->lines[1] = 0;
+      bptr->lengths[0] = bptr->lengths[1] = 0;
+
+      dt = process_diff_control (&scan_diff, bptr);
+      if (dt == ERROR || *scan_diff != '\n')
+	{
+	  fprintf (stderr, _("%s: diff failed: "), program_name);
+	  do
+	    {
+	      putc (*scan_diff, stderr);
+	    }
+	  while (*scan_diff++ != '\n');
+	  exit (EXIT_TROUBLE);
+	}
+      scan_diff++;
+
+      /* Force appropriate ranges to be null, if necessary */
+      switch (dt)
+	{
+	case ADD:
+	  bptr->ranges[0][0]++;
+	  break;
+	case DELETE:
+	  bptr->ranges[1][0]++;
+	  break;
+	case CHANGE:
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type in process_diff");
+	  break;
+	}
+
+      /* Allocate space for the pointers for the lines from filea, and
+	 parcel them out among these pointers */
+      if (dt != ADD)
+	{
+	  lin numlines = D_NUMLINES (bptr, 0);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
+	  bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[0][i]),
+					&(bptr->lengths[0][i]),
+					diff_limit,
+					'<');
+	}
+
+      /* Get past the separator for changes */
+      if (dt == CHANGE)
+	{
+	  if (strncmp (scan_diff, "---\n", 4))
+	    fatal ("invalid diff format; invalid change separator");
+	  scan_diff += 4;
+	}
+
+      /* Allocate space for the pointers for the lines from fileb, and
+	 parcel them out among these pointers */
+      if (dt != DELETE)
+	{
+	  lin numlines = D_NUMLINES (bptr, 1);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
+	  bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[1][i]),
+					&(bptr->lengths[1][i]),
+					diff_limit,
+					'>');
+	}
+
+      /* Place this block on the blocklist.  */
+      *block_list_end = bptr;
+      block_list_end = &bptr->next;
+    }
+
+  *block_list_end = NULL;
+  *last_block = bptr;
+  return block_list;
+}
+
+/* Skip tabs and spaces, and return the first character after them.  */
+
+static char *
+skipwhite (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    s++;
+  return s;
+}
+
+/* Read a nonnegative line number from S, returning the address of the
+   first character after the line number, and storing the number into
+   *PNUM.  Return 0 if S does not point to a valid line number.  */
+
+static char *
+readnum (char *s, lin *pnum)
+{
+  unsigned char c = *s;
+  lin num = 0;
+
+  if (! ISDIGIT (c))
+    return 0;
+
+  do
+    {
+      num = c - '0' + num * 10;
+      c = *++s;
+    }
+  while (ISDIGIT (c));
+
+  *pnum = num;
+  return s;
+}
+
+/* Parse a normal format diff control string.  Return the type of the
+   diff (ERROR if the format is bad).  All of the other important
+   information is filled into to the structure pointed to by db, and
+   the string pointer (whose location is passed to this routine) is
+   updated to point beyond the end of the string parsed.  Note that
+   only the ranges in the diff_block will be set by this routine.
+
+   If some specific pair of numbers has been reduced to a single
+   number, then both corresponding numbers in the diff block are set
+   to that number.  In general these numbers are interpreted as ranges
+   inclusive, unless being used by the ADD or DELETE commands.  It is
+   assumed that these will be special cased in a superior routine.   */
+
+static enum diff_type
+process_diff_control (char **string, struct diff_block *db)
+{
+  char *s = *string;
+  enum diff_type type;
+
+  /* Read first set of digits */
+  s = readnum (skipwhite (s), &db->ranges[0][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[0][RANGE_END]);
+      if (! s)
+	return ERROR;
+    }
+  else
+    db->ranges[0][RANGE_END] = db->ranges[0][RANGE_START];
+
+  /* Get the letter */
+  s = skipwhite (s);
+  switch (*s)
+    {
+    case 'a':
+      type = ADD;
+      break;
+    case 'c':
+      type = CHANGE;
+      break;
+    case 'd':
+      type = DELETE;
+      break;
+    default:
+      return ERROR;			/* Bad format */
+    }
+  s++;				/* Past letter */
+
+  /* Read second set of digits */
+  s = readnum (skipwhite (s), &db->ranges[1][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[1][RANGE_END]);
+      if (! s)
+	return ERROR;
+      s = skipwhite (s);		/* To move to end */
+    }
+  else
+    db->ranges[1][RANGE_END] = db->ranges[1][RANGE_START];
+
+  *string = s;
+  return type;
+}
+
+static char *
+read_diff (char const *filea,
+	   char const *fileb,
+	   char **output_placement)
+{
+  char *diff_result;
+  size_t current_chunk_size, total;
+  int fd, wstatus, status;
+  int werrno = 0;
+  struct stat pipestat;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+
+  char const *argv[9];
+  char const **ap;
+  int fds[2];
+  pid_t pid;
+
+  ap = argv;
+  *ap++ = diff_program;
+  if (text)
+    *ap++ = "-a";
+  if (strip_trailing_cr)
+    *ap++ = "--strip-trailing-cr";
+  *ap++ = "--horizon-lines=100";
+  *ap++ = "--";
+  *ap++ = filea;
+  *ap++ = fileb;
+  *ap = 0;
+
+  if (pipe (fds) != 0)
+    perror_with_exit ("pipe");
+
+  pid = vfork ();
+  if (pid == 0)
+    {
+      /* Child */
+      close (fds[0]);
+      if (fds[1] != STDOUT_FILENO)
+	{
+	  dup2 (fds[1], STDOUT_FILENO);
+	  close (fds[1]);
+	}
+
+      /* The cast to (char **) is needed for portability to older
+	 hosts with a nonstandard prototype for execvp.  */
+      execvp (diff_program, (char **) argv);
+
+      _exit (errno == ENOENT ? 127 : 126);
+    }
+
+  if (pid == -1)
+    perror_with_exit ("fork");
+
+  close (fds[1]);		/* Prevent erroneous lack of EOF */
+  fd = fds[0];
+
+#else
+
+  FILE *fpipe;
+  char const args[] = " --horizon-lines=100 -- ";
+  char *command = xmalloc (shell_quote_length (diff_program)
+			   + sizeof "-a"
+			   + sizeof "--strip-trailing-cr"
+			   + sizeof args - 1
+			   + shell_quote_length (filea) + 1
+			   + shell_quote_length (fileb) + 1);
+  char *p = command;
+  p = shell_quote_copy (p, diff_program);
+  if (text)
+    {
+      strcpy (p, " -a");
+      p += 3;
+    }
+  if (strip_trailing_cr)
+    {
+      strcpy (p, " --strip-trailing-cr");
+      p += 20;
+    }
+  strcpy (p, args);
+  p += sizeof args - 1;
+  p = shell_quote_copy (p, filea);
+  *p++ = ' ';
+  p = shell_quote_copy (p, fileb);
+  *p = 0;
+  errno = 0;
+  fpipe = popen (command, "r");
+  if (!fpipe)
+    perror_with_exit (command);
+  free (command);
+  fd = fileno (fpipe);
+
+#endif
+
+  if (fstat (fd, &pipestat) != 0)
+    perror_with_exit ("fstat");
+  current_chunk_size = MAX (1, STAT_BLOCKSIZE (pipestat));
+  diff_result = xmalloc (current_chunk_size);
+  total = 0;
+
+  for (;;)
+    {
+      size_t bytes_to_read = current_chunk_size - total;
+      size_t bytes = block_read (fd, diff_result + total, bytes_to_read);
+      total += bytes;
+      if (bytes != bytes_to_read)
+	{
+	  if (bytes == SIZE_MAX)
+	    perror_with_exit (_("read failed"));
+	  break;
+	}
+      if (PTRDIFF_MAX / 2 <= current_chunk_size)
+	xalloc_die ();
+      current_chunk_size *= 2;
+      diff_result = xrealloc (diff_result, current_chunk_size);
+    }
+
+  if (total != 0 && diff_result[total-1] != '\n')
+    fatal ("invalid diff format; incomplete last line");
+
+  *output_placement = diff_result;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+
+  wstatus = pclose (fpipe);
+  if (wstatus == -1)
+    werrno = errno;
+
+#else
+
+  if (close (fd) != 0)
+    perror_with_exit ("close");
+  if (waitpid (pid, &wstatus, 0) < 0)
+    perror_with_exit ("waitpid");
+
+#endif
+
+  status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+
+  if (EXIT_TROUBLE <= status)
+    error (EXIT_TROUBLE, werrno,
+	   _(status == 126
+	     ? "subsidiary program '%s' could not be invoked"
+	     : status == 127
+	     ? "subsidiary program '%s' not found"
+	     : status == INT_MAX
+	     ? "subsidiary program '%s' failed"
+	     : "subsidiary program '%s' failed (exit status %d)"),
+	   diff_program, status);
+
+  return diff_result + total;
+}
+
+
+/* Scan a regular diff line (consisting of > or <, followed by a
+   space, followed by text (including nulls) up to a newline.
+
+   This next routine began life as a macro and many parameters in it
+   are used as call-by-reference values.  */
+static char *
+scan_diff_line (char *scan_ptr, char **set_start, size_t *set_length,
+		char *limit, char leadingchar)
+{
+  char *line_ptr;
+
+  if (!(scan_ptr[0] == leadingchar
+	&& scan_ptr[1] == ' '))
+    fatal ("invalid diff format; incorrect leading line chars");
+
+  *set_start = line_ptr = scan_ptr + 2;
+  while (*line_ptr++ != '\n')
+    continue;
+
+  /* Include newline if the original line ended in a newline,
+     or if an edit script is being generated.
+     Copy any missing newline message to stderr if an edit script is being
+     generated, because edit scripts cannot handle missing newlines.
+     Return the beginning of the next line.  */
+  *set_length = line_ptr - *set_start;
+  if (line_ptr < limit && *line_ptr == '\\')
+    {
+      if (edscript)
+	fprintf (stderr, "%s:", program_name);
+      else
+	--*set_length;
+      line_ptr++;
+      do
+	{
+	  if (edscript)
+	    putc (*line_ptr, stderr);
+	}
+      while (*line_ptr++ != '\n');
+    }
+
+  return line_ptr;
+}
+
+/* Output a three way diff passed as a list of diff3_block's.  The
+   argument MAPPING is indexed by external file number (in the
+   argument list) and contains the internal file number (from the diff
+   passed).  This is important because the user expects outputs in
+   terms of the argument list number, and the diff passed may have
+   been done slightly differently (if the last argument was "-", for
+   example).  REV_MAPPING is the inverse of MAPPING.  */
+
+static void
+output_diff3 (FILE *outputfile, struct diff3_block *diff,
+	      int const mapping[3], int const rev_mapping[3])
+{
+  int i;
+  int oddoneout;
+  char *cp;
+  struct diff3_block *ptr;
+  lin line;
+  size_t length;
+  int dontprint;
+  static int skew_increment[3] = { 2, 3, 1 }; /* 0==>2==>1==>3 */
+  char const *line_prefix = initial_tab ? "\t" : "  ";
+
+  for (ptr = diff; ptr; ptr = D_NEXT (ptr))
+    {
+      char x[2];
+
+      switch (ptr->correspond)
+	{
+	case DIFF_ALL:
+	  x[0] = 0;
+	  dontprint = 3;	/* Print them all */
+	  oddoneout = 3;	/* Nobody's odder than anyone else */
+	  break;
+	case DIFF_1ST:
+	case DIFF_2ND:
+	case DIFF_3RD:
+	  oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
+
+	  x[0] = oddoneout + '1';
+	  x[1] = 0;
+	  dontprint = oddoneout == 0;
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type passed to output");
+	}
+      fprintf (outputfile, "====%s\n", x);
+
+      /* Go 0, 2, 1 if the first and third outputs are equivalent.  */
+      for (i = 0; i < 3;
+	   i = (oddoneout == 1 ? skew_increment[i] : i + 1))
+	{
+	  int realfile = mapping[i];
+	  lin lowt = D_LOWLINE (ptr, realfile);
+	  lin hight = D_HIGHLINE (ptr, realfile);
+	  long int llowt = lowt;
+	  long int lhight = hight;
+
+	  fprintf (outputfile, "%d:", i + 1);
+	  switch (lowt - hight)
+	    {
+	    case 1:
+	      fprintf (outputfile, "%lda\n", llowt - 1);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", llowt);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", llowt, lhight);
+	      break;
+	    }
+
+	  if (i == dontprint) continue;
+
+	  if (lowt <= hight)
+	    {
+	      line = 0;
+	      do
+		{
+		  fputs (line_prefix, outputfile);
+		  cp = D_RELNUM (ptr, realfile, line);
+		  length = D_RELLEN (ptr, realfile, line);
+		  fwrite (cp, sizeof (char), length, outputfile);
+		}
+	      while (++line < hight - lowt + 1);
+	      if (cp[length - 1] != '\n')
+		fprintf (outputfile, "\n\\ %s\n",
+			 _("No newline at end of file"));
+	    }
+	}
+    }
+}
+
+
+/* Output to OUTPUTFILE the lines of B taken from FILENUM.  Double any
+   initial '.'s; yield nonzero if any initial '.'s were doubled.  */
+
+static bool
+dotlines (FILE *outputfile, struct diff3_block *b, int filenum)
+{
+  lin i;
+  bool leading_dot = false;
+
+  for (i = 0;
+       i < D_NUMLINES (b, filenum);
+       i++)
+    {
+      char *line = D_RELNUM (b, filenum, i);
+      if (line[0] == '.')
+	{
+	  leading_dot = true;
+	  fputc ('.', outputfile);
+	}
+      fwrite (line, sizeof (char),
+	      D_RELLEN (b, filenum, i), outputfile);
+    }
+
+  return leading_dot;
+}
+
+/* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+   output a command that removes initial '.'s starting with line START
+   and continuing for NUM lines.  (START is long int, not lin, for
+   convenience with printf %ld formats.)  */
+
+static void
+undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
+{
+  fputs (".\n", outputfile);
+  if (leading_dot)
+    {
+      if (num == 1)
+	fprintf (outputfile, "%lds/^\\.//\n", start);
+      else
+	fprintf (outputfile, "%ld,%lds/^\\.//\n", start, start + num - 1);
+    }
+}
+
+/* Output a diff3 set of blocks as an ed script.  This script applies
+   the changes between file's 2 & 3 to file 1.  Take the precise
+   format of the ed script to be output from global variables set
+   during options processing.  Reverse the order of
+   the set of diff3 blocks in DIFF; this gets
+   around the problems involved with changing line numbers in an ed
+   script.
+
+   As in 'output_diff3', the variable MAPPING maps from file number
+   according to the argument list to file number according to the diff
+   passed.  All files listed below are in terms of the argument list.
+   REV_MAPPING is the inverse of MAPPING.
+
+   FILE0, FILE1 and FILE2 are the strings to print as the names of the
+   three files.  These may be the actual names, or may be the
+   arguments specified with -L.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_edscript (FILE *outputfile, struct diff3_block *diff,
+		       int const mapping[3], int const rev_mapping[3],
+		       char const *file0, char const *file1, char const *file2)
+{
+  bool leading_dot;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+
+  for (b = reverse_diff3_blocklist (diff); b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= (b->correspond == DIFF_ALL
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+
+      long int low0, high0;
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
+	}
+
+      low0 = D_LOWLINE (b, mapping[FILE0]);
+      high0 = D_HIGHLINE (b, mapping[FILE0]);
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+
+	  /* Mark end of conflict.  */
+
+	  fprintf (outputfile, "%lda\n", high0);
+	  leading_dot = false;
+	  if (type == DIFF_ALL)
+	    {
+	      if (show_2nd)
+		{
+		  /* Append lines from FILE1.  */
+		  fprintf (outputfile, "||||||| %s\n", file1);
+		  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+		}
+	      /* Append lines from FILE2.  */
+	      fputs ("=======\n", outputfile);
+	      leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
+	    }
+	  fprintf (outputfile, ">>>>>>> %s\n", file2);
+	  undotlines (outputfile, leading_dot, high0 + 2,
+		      (D_NUMLINES (b, mapping[FILE1])
+		       + D_NUMLINES (b, mapping[FILE2]) + 1));
+
+
+	  /* Mark start of conflict.  */
+
+	  fprintf (outputfile, "%lda\n<<<<<<< %s\n", low0 - 1,
+		   type == DIFF_ALL ? file0 : file1);
+	  leading_dot = false;
+	  if (type == DIFF_2ND)
+	    {
+	      /* Prepend lines from FILE1.  */
+	      leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+	      fputs ("=======\n", outputfile);
+	    }
+	  undotlines (outputfile, leading_dot, low0 + 1,
+		      D_NUMLINES (b, mapping[FILE1]));
+	}
+      else if (D_NUMLINES (b, mapping[FILE2]) == 0)
+	/* Write out a delete */
+	{
+	  if (low0 == high0)
+	    fprintf (outputfile, "%ldd\n", low0);
+	  else
+	    fprintf (outputfile, "%ld,%ldd\n", low0, high0);
+	}
+      else
+	/* Write out an add or change */
+	{
+	  switch (high0 - low0)
+	    {
+	    case -1:
+	      fprintf (outputfile, "%lda\n", high0);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", high0);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", low0, high0);
+	      break;
+	    }
+
+	  undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
+		      low0, D_NUMLINES (b, mapping[FILE2]));
+	}
+    }
+  if (finalwrite)
+    fputs ("w\nq\n", outputfile);
+  return conflicts_found;
+}
+
+/* Read from INFILE and output to OUTPUTFILE a set of diff3_blocks
+   DIFF as a merged file.  This acts like 'ed file0
+   <[output_diff3_edscript]', except that it works even for binary
+   data or incomplete lines.
+
+   As before, MAPPING maps from arg list file number to diff file
+   number, REV_MAPPING is its inverse, and FILE0, FILE1, and FILE2 are
+   the names of the files.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_merge (FILE *infile, FILE *outputfile, struct diff3_block *diff,
+		    int const mapping[3], int const rev_mapping[3],
+		    char const *file0, char const *file1, char const *file2)
+{
+  int c;
+  lin i;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+  lin linesread = 0;
+
+  for (b = diff; b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= ((b->correspond == DIFF_ALL)
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+      char const *format_2nd = "<<<<<<< %s\n";
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging;
+	  format_2nd = "||||||| %s\n";
+	  break;
+	}
+
+      /* Copy I lines from file 0.  */
+      i = D_LOWLINE (b, FILE0) - linesread - 1;
+      linesread += i;
+      while (0 <= --i)
+	do
+	  {
+	    c = getc (infile);
+	    if (c == EOF)
+	      {
+		if (ferror (infile))
+		  perror_with_exit (_("read failed"));
+		else if (feof (infile))
+		  fatal ("input file shrank");
+	      }
+	    putc (c, outputfile);
+	  }
+	while (c != '\n');
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+	  if (type == DIFF_ALL)
+	    {
+	      /* Put in lines from FILE0 with bracket.  */
+	      fprintf (outputfile, "<<<<<<< %s\n", file0);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE0]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE0], i), outputfile);
+	    }
+
+	  if (show_2nd)
+	    {
+	      /* Put in lines from FILE1 with bracket.  */
+	      fprintf (outputfile, format_2nd, file1);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE1]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE1], i), outputfile);
+	    }
+
+	  fputs ("=======\n", outputfile);
+	}
+
+      /* Put in lines from FILE2.  */
+      for (i = 0;
+	   i < D_NUMLINES (b, mapping[FILE2]);
+	   i++)
+	fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
+		D_RELLEN (b, mapping[FILE2], i), outputfile);
+
+      if (conflict)
+	fprintf (outputfile, ">>>>>>> %s\n", file2);
+
+      /* Skip I lines in file 0.  */
+      i = D_NUMLINES (b, FILE0);
+      linesread += i;
+      while (0 <= --i)
+	while ((c = getc (infile)) != '\n')
+	  if (c == EOF)
+	    {
+	      if (ferror (infile))
+		perror_with_exit (_("read failed"));
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
+    }
+  /* Copy rest of common file.  */
+  while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
+    putc (c, outputfile);
+  return conflicts_found;
+}
+
+/* Reverse the order of the list of diff3 blocks.  */
+
+static struct diff3_block *
+reverse_diff3_blocklist (struct diff3_block *diff)
+{
+  register struct diff3_block *tmp, *next, *prev;
+
+  for (tmp = diff, prev = 0;  tmp;  tmp = next)
+    {
+      next = tmp->next;
+      tmp->next = prev;
+      prev = tmp;
+    }
+
+  return prev;
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+static void
+perror_with_exit (char const *string)
+{
+  error (EXIT_TROUBLE, errno, "%s", string);
+  abort ();
+}
diff --git a/src/dir.c.orig b/src/dir.c.orig
new file mode 100644
index 0000000..1bb374f
--- /dev/null
+++ b/src/dir.c.orig
@@ -0,0 +1,283 @@
+/* Read, sort and compare two directories.  Used for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <error.h>
+#include <exclude.h>
+#include <setjmp.h>
+#include <xalloc.h>
+
+/* Read the directory named by DIR and store into DIRDATA a sorted vector
+   of filenames for its contents.  DIR->desc == -1 means this directory is
+   known to be nonexistent, so set DIRDATA to an empty vector.
+   Return -1 (setting errno) if error, 0 otherwise.  */
+
+struct dirdata
+{
+  size_t nnames;	/* Number of names.  */
+  char const **names;	/* Sorted names of files in dir, followed by 0.  */
+  char *data;	/* Allocated storage for file names.  */
+};
+
+/* Whether file names in directories should be compared with
+   locale-specific sorting.  */
+static bool locale_specific_sorting;
+
+/* Where to go if locale-specific sorting fails.  */
+static jmp_buf failed_locale_specific_sorting;
+
+static bool dir_loop (struct comparison const *, int);
+static int compare_names_for_qsort (void const *, void const *);
+
+
+/* Read a directory and get its vector of names.  */
+
+static bool
+dir_read (struct file_data const *dir, struct dirdata *dirdata)
+{
+  register struct dirent *next;
+  register size_t i;
+
+  /* Address of block containing the files that are described.  */
+  char const **names;
+
+  /* Number of files in directory.  */
+  size_t nnames;
+
+  /* Allocated and used storage for file name data.  */
+  char *data;
+  size_t data_alloc, data_used;
+
+  dirdata->names = 0;
+  dirdata->data = 0;
+  nnames = 0;
+  data = 0;
+
+  if (dir->desc != -1)
+    {
+      /* Open the directory and check for errors.  */
+      register DIR *reading = opendir (dir->name);
+      if (!reading)
+	return false;
+
+      /* Initialize the table of filenames.  */
+
+      data_alloc = 512;
+      data_used = 0;
+      dirdata->data = data = xmalloc (data_alloc);
+
+      /* Read the directory entries, and insert the subfiles
+	 into the `data' table.  */
+
+      while ((errno = 0, (next = readdir (reading)) != 0))
+	{
+	  char *d_name = next->d_name;
+	  size_t d_size = _D_EXACT_NAMLEN (next) + 1;
+
+	  /* Ignore "." and "..".  */
+	  if (d_name[0] == '.'
+	      && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
+	    continue;
+
+	  if (excluded_file_name (excluded, d_name))
+	    continue;
+
+	  while (data_alloc < data_used + d_size)
+	    {
+	      if (PTRDIFF_MAX / 2 <= data_alloc)
+		xalloc_die ();
+	      dirdata->data = data = xrealloc (data, data_alloc *= 2);
+	    }
+
+	  memcpy (data + data_used, d_name, d_size);
+	  data_used += d_size;
+	  nnames++;
+	}
+      if (errno)
+	{
+	  int e = errno;
+	  closedir (reading);
+	  errno = e;
+	  return false;
+	}
+#if CLOSEDIR_VOID
+      closedir (reading);
+#else
+      if (closedir (reading) != 0)
+	return false;
+#endif
+    }
+
+  /* Create the 'names' table from the 'data' table.  */
+  if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+    xalloc_die ();
+  dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+  dirdata->nnames = nnames;
+  for (i = 0;  i < nnames;  i++)
+    {
+      names[i] = data;
+      data += strlen (data) + 1;
+    }
+  names[nnames] = 0;
+  return true;
+}
+
+/* Compare file names, returning a value compatible with strcmp.  */
+
+static int
+compare_names (char const *name1, char const *name2)
+{
+  if (locale_specific_sorting)
+    {
+      int r;
+      errno = 0;
+      if (ignore_file_name_case)
+	r = strcasecoll (name1, name2);
+      else
+	r = strcoll (name1, name2);
+      if (errno)
+	{
+	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+		 name1, name2);
+	  longjmp (failed_locale_specific_sorting, 1);
+	}
+      return r;
+    }
+
+  return (ignore_file_name_case
+	  ? strcasecmp (name1, name2)
+	  : file_name_cmp (name1, name2));
+}
+
+/* A wrapper for compare_names suitable as an argument for qsort.  */
+
+static int
+compare_names_for_qsort (void const *file1, void const *file2)
+{
+  char const *const *f1 = file1;
+  char const *const *f2 = file2;
+  return compare_names (*f1, *f2);
+}
+
+/* Compare the contents of two directories named in CMP.
+   This is a top-level routine; it does everything necessary for diff
+   on two directories.
+
+   CMP->file[0].desc == -1 says directory CMP->file[0] doesn't exist,
+   but pretend it is empty.  Likewise for CMP->file[1].
+
+   HANDLE_FILE is a caller-provided subroutine called to handle each file.
+   It gets three operands: CMP, name of file in dir 0, name of file in dir 1.
+   These names are relative to the original working directory.
+
+   For a file that appears in only one of the dirs, one of the name-args
+   to HANDLE_FILE is zero.
+
+   Returns the maximum of all the values returned by HANDLE_FILE,
+   or EXIT_TROUBLE if trouble is encountered in opening files.  */
+
+int
+diff_dirs (struct comparison const *cmp,
+	   int (*handle_file) (struct comparison const *,
+			       char const *, char const *))
+{
+  struct dirdata dirdata[2];
+  int volatile val = EXIT_SUCCESS;
+  int i;
+
+  if ((cmp->file[0].desc == -1 || dir_loop (cmp, 0))
+      && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
+    {
+      error (0, 0, _("%s: recursive directory loop"),
+	     cmp->file[cmp->file[0].desc == -1].name);
+      return EXIT_TROUBLE;
+    }
+
+  /* Get contents of both dirs.  */
+  for (i = 0; i < 2; i++)
+    if (! dir_read (&cmp->file[i], &dirdata[i]))
+      {
+	perror_with_name (cmp->file[i].name);
+	val = EXIT_TROUBLE;
+      }
+
+  if (val == EXIT_SUCCESS)
+    {
+      char const **volatile names[2];
+      names[0] = dirdata[0].names;
+      names[1] = dirdata[1].names;
+
+      /* Use locale-specific sorting if possible, else native byte order.  */
+      locale_specific_sorting = true;
+      if (setjmp (failed_locale_specific_sorting))
+	locale_specific_sorting = false;
+
+      /* Sort the directories.  */
+      for (i = 0; i < 2; i++)
+	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+	       compare_names_for_qsort);
+
+      /* If '-S name' was given, and this is the topmost level of comparison,
+	 ignore all file names less than the specified starting name.  */
+
+      if (starting_file && ! cmp->parent)
+	{
+	  while (*names[0] && compare_names (*names[0], starting_file) < 0)
+	    names[0]++;
+	  while (*names[1] && compare_names (*names[1], starting_file) < 0)
+	    names[1]++;
+	}
+
+      /* Loop while files remain in one or both dirs.  */
+      while (*names[0] || *names[1])
+	{
+	  /* Compare next name in dir 0 with next name in dir 1.
+	     At the end of a dir,
+	     pretend the "next name" in that dir is very large.  */
+	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+			   : compare_names (*names[0], *names[1]));
+	  int v1 = (*handle_file) (cmp,
+				   0 < nameorder ? 0 : *names[0]++,
+				   nameorder < 0 ? 0 : *names[1]++);
+	  if (val < v1)
+	    val = v1;
+	}
+    }
+
+  for (i = 0; i < 2; i++)
+    {
+      free (dirdata[i].names);
+      free (dirdata[i].data);
+    }
+
+  return val;
+}
+
+/* Return nonzero if CMP is looping recursively in argument I.  */
+
+static bool
+dir_loop (struct comparison const *cmp, int i)
+{
+  struct comparison const *p = cmp;
+  while ((p = p->parent))
+    if (0 < same_file (&p->file[i].stat, &cmp->file[i].stat))
+      return true;
+  return false;
+}
diff --git a/src/sdiff.c.orig b/src/sdiff.c.orig
new file mode 100644
index 0000000..fb15fbe
--- /dev/null
+++ b/src/sdiff.c.orig
@@ -0,0 +1,1236 @@
+/* sdiff - side-by-side merge of file differences
+
+   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "sdiff"
+
+#define AUTHORS \
+  proper_name ("Thomas Lord")
+
+/* Size of chunks read from files which must be parsed into lines.  */
+#define SDIFF_BUFSIZE ((size_t) 65536)
+
+static char const *editor_program = DEFAULT_EDITOR_PROGRAM;
+static char const **diffargv;
+
+static char * volatile tmpname;
+static FILE *tmp;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t volatile diffpid;
+#endif
+
+struct line_filter;
+
+static void catchsig (int);
+static bool edit (struct line_filter *, char const *, lin, lin, struct line_filter *, char const *, lin, lin, FILE *);
+static bool interact (struct line_filter *, struct line_filter *, char const *, struct line_filter *, char const *, FILE *);
+static void checksigs (void);
+static void diffarg (char const *);
+static void fatal (char const *) __attribute__((noreturn));
+static void perror_fatal (char const *) __attribute__((noreturn));
+static void trapsigs (void);
+static void untrapsig (int);
+
+#define NUM_SIGS (sizeof sigs / sizeof *sigs)
+static int const sigs[] = {
+#ifdef SIGHUP
+       SIGHUP,
+#endif
+#ifdef SIGQUIT
+       SIGQUIT,
+#endif
+#ifdef SIGTERM
+       SIGTERM,
+#endif
+#ifdef SIGXCPU
+       SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+       SIGXFSZ,
+#endif
+#ifdef SIGPIPE
+       SIGPIPE,
+# define handler_index_of_SIGPIPE (NUM_SIGS - 2)
+#endif
+       SIGINT
+#define handler_index_of_SIGINT (NUM_SIGS - 1)
+};
+
+#if HAVE_SIGACTION
+  /* Prefer 'sigaction' if available, since 'signal' can lose signals.  */
+  static struct sigaction initial_action[NUM_SIGS];
+# define initial_handler(i) (initial_action[i].sa_handler)
+  static void signal_handler (int, void (*) (int));
+#else
+  static void (*initial_action[NUM_SIGS]) ();
+# define initial_handler(i) (initial_action[i])
+# define signal_handler(sig, handler) signal (sig, handler)
+#endif
+
+#if ! HAVE_SIGPROCMASK
+# define sigset_t int
+# define sigemptyset(s) (*(s) = 0)
+# ifndef sigmask
+#  define sigmask(sig) (1 << ((sig) - 1))
+# endif
+# define sigaddset(s, sig) (*(s) |= sigmask (sig))
+# ifndef SIG_BLOCK
+#  define SIG_BLOCK 0
+# endif
+# ifndef SIG_SETMASK
+#  define SIG_SETMASK (! SIG_BLOCK)
+# endif
+# if ! HAVE_SIGBLOCK
+#  define sigblock(mask) (mask)
+#  define sigsetmask(mask) (mask)
+# endif
+# define sigprocmask(how, n, o) \
+    ((how) == SIG_BLOCK \
+     ? ((o) ? (*(sigset_t *) (o) = sigblock (*(n))) : sigblock (*(n))) \
+     : sigsetmask (*(n)))
+#endif
+
+static bool diraccess (char const *);
+static int temporary_file (void);
+
+/* Options: */
+
+/* Name of output file if -o specified.  */
+static char const *output;
+
+/* Do not print common lines.  */
+static bool suppress_common_lines;
+
+/* Value for the long option that does not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  TABSIZE_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"expand-tabs", 0, 0, 't'},
+  {"help", 0, 0, HELP_OPTION},
+  {"ignore-all-space", 0, 0, 'W'}, /* swap W and w for historical reasons */
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"left-column", 0, 0, 'l'},
+  {"minimal", 0, 0, 'd'},
+  {"output", 1, 0, 'o'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-common-lines", 0, 0, 's'},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'w'},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_fatal (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-o FILE  --output=FILE  Operate interactively, sending output to FILE."),
+  "",
+  N_("-i  --ignore-case  Consider upper- and lower-case to be the same."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-W  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-w NUM  --width=NUM  Output at most NUM (default 130) print columns."),
+  N_("-l  --left-column  Output only the left column of common lines."),
+  N_("-s  --suppress-common-lines  Do not output common lines."),
+  "",
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  "",
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("-H  --speed-large-files  Assume large files and many scattered small changes."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+  printf ("%s\n\n", _("Side-by-side merge of file differences."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Clean up after a signal or other failure.  This function is
+   async-signal-safe.  */
+static void
+cleanup (int signo __attribute__((unused)))
+{
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+  if (0 < diffpid)
+    kill (diffpid, SIGPIPE);
+#endif
+  if (tmpname)
+    unlink (tmpname);
+}
+
+static void exiterr (void) __attribute__((noreturn));
+static void
+exiterr (void)
+{
+  cleanup (0);
+  untrapsig (0);
+  checksigs ();
+  exit (EXIT_TROUBLE);
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (0, 0, "%s", _(msgid));
+  exiterr ();
+}
+
+static void
+perror_fatal (char const *msg)
+{
+  int e = errno;
+  checksigs ();
+  error (0, e, "%s", msg);
+  exiterr ();
+}
+
+static void
+check_child_status (int werrno, int wstatus, int max_ok_status,
+		    char const *subsidiary_program)
+{
+  int status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+
+  if (max_ok_status < status)
+    {
+      error (0, werrno,
+	     _(status == 126
+	       ? "subsidiary program '%s' could not be invoked"
+	       : status == 127
+	       ? "subsidiary program '%s' not found"
+	       : status == INT_MAX
+	       ? "subsidiary program '%s' failed"
+	       : "subsidiary program '%s' failed (exit status %d)"),
+	     subsidiary_program, status);
+      exiterr ();
+    }
+}
+
+static FILE *
+ck_fopen (char const *fname, char const *type)
+{
+  FILE *r = fopen (fname, type);
+  if (! r)
+    perror_fatal (fname);
+  return r;
+}
+
+static void
+ck_fclose (FILE *f)
+{
+  if (fclose (f))
+    perror_fatal ("fclose");
+}
+
+static size_t
+ck_fread (char *buf, size_t size, FILE *f)
+{
+  size_t r = fread (buf, sizeof (char), size, f);
+  if (r == 0 && ferror (f))
+    perror_fatal (_("read failed"));
+  return r;
+}
+
+static void
+ck_fwrite (char const *buf, size_t size, FILE *f)
+{
+  if (fwrite (buf, sizeof (char), size, f) != size)
+    perror_fatal (_("write failed"));
+}
+
+static void
+ck_fflush (FILE *f)
+{
+  if (fflush (f) != 0)
+    perror_fatal (_("write failed"));
+}
+
+static char const *
+expand_name (char *name, bool is_dir, char const *other_name)
+{
+  if (STREQ (name, "-"))
+    fatal ("cannot interactively merge standard input");
+  if (! is_dir)
+    return name;
+  else
+    {
+      /* Yield NAME/BASE, where BASE is OTHER_NAME's basename.  */
+      char const *base = last_component (other_name);
+      size_t namelen = strlen (name), baselen = base_len (base);
+      bool insert_slash = *last_component (name) && name[namelen - 1] != '/';
+      char *r = xmalloc (namelen + insert_slash + baselen + 1);
+      memcpy (r, name, namelen);
+      r[namelen] = '/';
+      memcpy (r + namelen + insert_slash, base, baselen);
+      r[namelen + insert_slash + baselen] = '\0';
+      return r;
+    }
+}
+
+struct line_filter {
+  FILE *infile;
+  char *bufpos;
+  char *buffer;
+  char *buflim;
+};
+
+static void
+lf_init (struct line_filter *lf, FILE *infile)
+{
+  lf->infile = infile;
+  lf->bufpos = lf->buffer = lf->buflim = xmalloc (SDIFF_BUFSIZE + 1);
+  lf->buflim[0] = '\n';
+}
+
+/* Fill an exhausted line_filter buffer from its INFILE */
+static size_t
+lf_refill (struct line_filter *lf)
+{
+  size_t s = ck_fread (lf->buffer, SDIFF_BUFSIZE, lf->infile);
+  lf->bufpos = lf->buffer;
+  lf->buflim = lf->buffer + s;
+  lf->buflim[0] = '\n';
+  checksigs ();
+  return s;
+}
+
+/* Advance LINES on LF's infile, copying lines to OUTFILE */
+static void
+lf_copy (struct line_filter *lf, lin lines, FILE *outfile)
+{
+  char *start = lf->bufpos;
+
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  ck_fwrite (start, lf->buflim - start, outfile);
+	  if (! lf_refill (lf))
+	    return;
+	  start = lf->bufpos;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+
+  ck_fwrite (start, lf->bufpos - start, outfile);
+}
+
+/* Advance LINES on LF's infile without doing output */
+static void
+lf_skip (struct line_filter *lf, lin lines)
+{
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  if (! lf_refill (lf))
+	    break;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+}
+
+/* Snarf a line into a buffer.  Return EOF if EOF, 0 if error, 1 if OK.  */
+static int
+lf_snarf (struct line_filter *lf, char *buffer, size_t bufsize)
+{
+  for (;;)
+    {
+      char *start = lf->bufpos;
+      char *next = (char *) memchr (start, '\n', lf->buflim + 1 - start);
+      size_t s = next - start;
+      if (bufsize <= s)
+	return 0;
+      memcpy (buffer, start, s);
+      if (next < lf->buflim)
+	{
+	  buffer[s] = 0;
+	  lf->bufpos = next + 1;
+	  return 1;
+	}
+      if (! lf_refill (lf))
+	return s ? 0 : EOF;
+      buffer += s;
+      bufsize -= s;
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int opt;
+  char const *prog;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (cleanup);
+
+  prog = getenv ("EDITOR");
+  if (prog)
+    editor_program = prog;
+
+  diffarg (DEFAULT_DIFF_PROGRAM);
+
+  /* parse command line args */
+  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:W", longopts, 0))
+	 != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  diffarg ("-a");
+	  break;
+
+	case 'b':
+	  diffarg ("-b");
+	  break;
+
+	case 'B':
+	  diffarg ("-B");
+	  break;
+
+	case 'd':
+	  diffarg ("-d");
+	  break;
+
+	case 'E':
+	  diffarg ("-E");
+	  break;
+
+	case 'H':
+	  diffarg ("-H");
+	  break;
+
+	case 'i':
+	  diffarg ("-i");
+	  break;
+
+	case 'I':
+	  diffarg ("-I");
+	  diffarg (optarg);
+	  break;
+
+	case 'l':
+	  diffarg ("--left-column");
+	  break;
+
+	case 'o':
+	  output = optarg;
+	  break;
+
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+
+	case 't':
+	  diffarg ("-t");
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  diffarg ("-W");
+	  diffarg (optarg);
+	  break;
+
+	case 'W':
+	  diffarg ("-w");
+	  break;
+
+	case DIFF_PROGRAM_OPTION:
+	  diffargv[0] = optarg;
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  diffarg ("--strip-trailing-cr");
+	  break;
+
+	case TABSIZE_OPTION:
+	  diffarg ("--tabsize");
+	  diffarg (optarg);
+	  break;
+
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  if (argc - optind != 2)
+    {
+      if (argc - optind < 2)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 2]);
+    }
+
+  if (! output)
+    {
+      /* easy case: diff does everything for us */
+      if (suppress_common_lines)
+	diffarg ("--suppress-common-lines");
+      diffarg ("-y");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+      execvp (diffargv[0], (char **) diffargv);
+      perror_fatal (diffargv[0]);
+    }
+  else
+    {
+      char const *lname, *rname;
+      FILE *left, *right, *out, *diffout;
+      bool interact_ok;
+      struct line_filter lfilt;
+      struct line_filter rfilt;
+      struct line_filter diff_filt;
+      bool leftdir = diraccess (argv[optind]);
+      bool rightdir = diraccess (argv[optind + 1]);
+
+      if (leftdir & rightdir)
+	fatal ("both files to be compared are directories");
+
+      lname = expand_name (argv[optind], leftdir, argv[optind + 1]);
+      left = ck_fopen (lname, "r");
+      rname = expand_name (argv[optind + 1], rightdir, argv[optind]);
+      right = ck_fopen (rname, "r");
+      out = ck_fopen (output, "w");
+
+      diffarg ("--sdiff-merge-assist");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+
+      trapsigs ();
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      {
+	size_t cmdsize = 1;
+	char *p, *command;
+	int i;
+
+	for (i = 0;  diffargv[i];  i++)
+	  cmdsize += shell_quote_length (diffargv[i]) + 1;
+	command = p = xmalloc (cmdsize);
+	for (i = 0;  diffargv[i];  i++)
+	  {
+	    p = shell_quote_copy (p, diffargv[i]);
+	    *p++ = ' ';
+	  }
+	p[-1] = 0;
+	errno = 0;
+	diffout = popen (command, "r");
+	if (! diffout)
+	  perror_fatal (command);
+	free (command);
+      }
+#else
+      {
+	int diff_fds[2];
+# if HAVE_WORKING_VFORK
+	sigset_t procmask;
+	sigset_t blocked;
+# endif
+
+	if (pipe (diff_fds) != 0)
+	  perror_fatal ("pipe");
+
+# if HAVE_WORKING_VFORK
+	/* Block SIGINT and SIGPIPE.  */
+	sigemptyset (&blocked);
+	sigaddset (&blocked, SIGINT);
+	sigaddset (&blocked, SIGPIPE);
+	sigprocmask (SIG_BLOCK, &blocked, &procmask);
+# endif
+	diffpid = vfork ();
+	if (diffpid < 0)
+	  perror_fatal ("fork");
+	if (! diffpid)
+	  {
+	    /* Alter the child's SIGINT and SIGPIPE handlers;
+	       this may munge the parent.
+	       The child ignores SIGINT in case the user interrupts the editor.
+	       The child does not ignore SIGPIPE, even if the parent does.  */
+	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	      signal_handler (SIGINT, SIG_IGN);
+	    signal_handler (SIGPIPE, SIG_DFL);
+# if HAVE_WORKING_VFORK
+	    /* Stop blocking SIGINT and SIGPIPE in the child.  */
+	    sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+	    close (diff_fds[0]);
+	    if (diff_fds[1] != STDOUT_FILENO)
+	      {
+		dup2 (diff_fds[1], STDOUT_FILENO);
+		close (diff_fds[1]);
+	      }
+
+	    execvp (diffargv[0], (char **) diffargv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+
+# if HAVE_WORKING_VFORK
+	/* Restore the parent's SIGINT and SIGPIPE behavior.  */
+	if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	  signal_handler (SIGINT, catchsig);
+	if (initial_handler (handler_index_of_SIGPIPE) != SIG_IGN)
+	  signal_handler (SIGPIPE, catchsig);
+	else
+	  signal_handler (SIGPIPE, SIG_IGN);
+
+	/* Stop blocking SIGINT and SIGPIPE in the parent.  */
+	sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+
+	close (diff_fds[1]);
+	diffout = fdopen (diff_fds[0], "r");
+	if (! diffout)
+	  perror_fatal ("fdopen");
+      }
+#endif
+
+      lf_init (&diff_filt, diffout);
+      lf_init (&lfilt, left);
+      lf_init (&rfilt, right);
+
+      interact_ok = interact (&diff_filt, &lfilt, lname, &rfilt, rname, out);
+
+      ck_fclose (left);
+      ck_fclose (right);
+      ck_fclose (out);
+
+      {
+	int wstatus;
+	int werrno = 0;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+	wstatus = pclose (diffout);
+	if (wstatus == -1)
+	  werrno = errno;
+#else
+	ck_fclose (diffout);
+	while (waitpid (diffpid, &wstatus, 0) < 0)
+	  if (errno == EINTR)
+	    checksigs ();
+	  else
+	    perror_fatal ("waitpid");
+	diffpid = 0;
+#endif
+
+	if (tmpname)
+	  {
+	    unlink (tmpname);
+	    tmpname = 0;
+	  }
+
+	if (! interact_ok)
+	  exiterr ();
+
+	check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
+	untrapsig (0);
+	checksigs ();
+	exit (WEXITSTATUS (wstatus));
+      }
+    }
+  return EXIT_SUCCESS;			/* Fool '-Wall'.  */
+}
+
+static void
+diffarg (char const *a)
+{
+  static size_t diffargs, diffarglim;
+
+  if (diffargs == diffarglim)
+    {
+      if (! diffarglim)
+	diffarglim = 16;
+      else if (PTRDIFF_MAX / (2 * sizeof *diffargv) <= diffarglim)
+	xalloc_die ();
+      else
+	diffarglim *= 2;
+      diffargv = xrealloc (diffargv, diffarglim * sizeof *diffargv);
+    }
+  diffargv[diffargs++] = a;
+}
+
+/* Signal handling */
+
+static bool volatile ignore_SIGINT;
+static int volatile signal_received;
+static bool sigs_trapped;
+
+static void
+catchsig (int s)
+{
+#if ! HAVE_SIGACTION
+  signal (s, SIG_IGN);
+#endif
+  if (! (s == SIGINT && ignore_SIGINT))
+    signal_received = s;
+}
+
+#if HAVE_SIGACTION
+static struct sigaction catchaction;
+
+static void
+signal_handler (int sig, void (*handler) (int))
+{
+  catchaction.sa_handler = handler;
+  sigaction (sig, &catchaction, 0);
+}
+#endif
+
+static void
+trapsigs (void)
+{
+  int i;
+
+#if HAVE_SIGACTION
+  catchaction.sa_flags = SA_RESTART;
+  sigemptyset (&catchaction.sa_mask);
+  for (i = 0;  i < NUM_SIGS;  i++)
+    sigaddset (&catchaction.sa_mask, sigs[i]);
+#endif
+
+  for (i = 0;  i < NUM_SIGS;  i++)
+    {
+#if HAVE_SIGACTION
+      sigaction (sigs[i], 0, &initial_action[i]);
+#else
+      initial_action[i] = signal (sigs[i], SIG_IGN);
+#endif
+      if (initial_handler (i) != SIG_IGN)
+	signal_handler (sigs[i], catchsig);
+    }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  sigs_trapped = true;
+}
+
+/* Untrap signal S, or all trapped signals if S is zero.  */
+static void
+untrapsig (int s)
+{
+  int i;
+
+  if (sigs_trapped)
+    for (i = 0;  i < NUM_SIGS;  i++)
+      if ((! s || sigs[i] == s)  &&  initial_handler (i) != SIG_IGN)
+	{
+#if HAVE_SIGACTION
+	  sigaction (sigs[i], &initial_action[i], 0);
+#else
+	  signal (sigs[i], initial_action[i]);
+#endif
+	}
+}
+
+/* Exit if a signal has been received.  */
+static void
+checksigs (void)
+{
+  int s = signal_received;
+  if (s)
+    {
+      cleanup (0);
+
+      /* Yield an exit status indicating that a signal was received.  */
+      untrapsig (s);
+      kill (getpid (), s);
+
+      /* That didn't work, so exit with error status.  */
+      exit (EXIT_TROUBLE);
+    }
+}
+
+static void
+give_help (void)
+{
+  fprintf (stderr, "%s", _("\
+ed:\tEdit then use both versions, each decorated with a header.\n\
+eb:\tEdit then use both versions.\n\
+el or e1:\tEdit then use the left version.\n\
+er or e2:\tEdit then use the right version.\n\
+e:\tDiscard both versions then edit a new one.\n\
+l or 1:\tUse the left version.\n\
+r or 2:\tUse the right version.\n\
+s:\tSilently include common lines.\n\
+v:\tVerbosely include common lines.\n\
+q:\tQuit.\n\
+"));
+}
+
+static int
+skip_white (void)
+{
+  int c;
+  for (;;)
+    {
+      c = getchar ();
+      if (! isspace (c) || c == '\n')
+	break;
+      checksigs ();
+    }
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+  return c;
+}
+
+static void
+flush_line (void)
+{
+  int c;
+  while ((c = getchar ()) != '\n' && c != EOF)
+    continue;
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+}
+
+
+/* interpret an edit command */
+static bool
+edit (struct line_filter *left, char const *lname, lin lline, lin llen,
+      struct line_filter *right, char const *rname, lin rline, lin rlen,
+      FILE *outfile)
+{
+  for (;;)
+    {
+      int cmd0 IF_LINT (= 0);
+      int cmd1 IF_LINT (= 0);
+      bool gotcmd = false;
+
+      while (! gotcmd)
+	{
+	  if (putchar ('%') != '%')
+	    perror_fatal (_("write failed"));
+	  ck_fflush (stdout);
+
+	  cmd0 = skip_white ();
+	  switch (cmd0)
+	    {
+	    case '1': case '2': case 'l': case 'r':
+	    case 's': case 'v': case 'q':
+	      if (skip_white () != '\n')
+		{
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      gotcmd = true;
+	      break;
+
+	    case 'e':
+	      cmd1 = skip_white ();
+	      switch (cmd1)
+		{
+		case '1': case '2': case 'b': case 'd': case 'l': case 'r':
+		  if (skip_white () != '\n')
+		    {
+		      give_help ();
+		      flush_line ();
+		      continue;
+		    }
+		  gotcmd = true;
+		  break;
+		case '\n':
+		  gotcmd = true;
+		  break;
+		default:
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      break;
+
+	    case EOF:
+	      if (feof (stdin))
+		{
+		  gotcmd = true;
+		  cmd0 = 'q';
+		  break;
+		}
+	      /* Fall through.  */
+	    default:
+	      flush_line ();
+	      /* Fall through.  */
+	    case '\n':
+	      give_help ();
+	      continue;
+	    }
+	}
+
+      switch (cmd0)
+	{
+	case '1': case 'l':
+	  lf_copy (left, llen, outfile);
+	  lf_skip (right, rlen);
+	  return true;
+	case '2': case 'r':
+	  lf_copy (right, rlen, outfile);
+	  lf_skip (left, llen);
+	  return true;
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+	case 'v':
+	  suppress_common_lines = false;
+	  break;
+	case 'q':
+	  return false;
+	case 'e':
+	  {
+	    int fd;
+
+	    if (tmpname)
+	      tmp = fopen (tmpname, "w");
+	    else
+	      {
+		if ((fd = temporary_file ()) < 0)
+		  perror_fatal ("mkstemp");
+		tmp = fdopen (fd, "w");
+	      }
+
+	    if (! tmp)
+	      perror_fatal (tmpname);
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (llen)
+		  {
+		    if (llen == 1)
+		      fprintf (tmp, "--- %s %ld\n", lname, (long int) lline);
+		    else
+		      fprintf (tmp, "--- %s %ld,%ld\n", lname,
+			       (long int) lline,
+			       (long int) (lline + llen - 1));
+		  }
+		/* Fall through.  */
+	      case '1': case 'b': case 'l':
+		lf_copy (left, llen, tmp);
+		break;
+
+	      default:
+		lf_skip (left, llen);
+		break;
+	      }
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (rlen)
+		  {
+		    if (rlen == 1)
+		      fprintf (tmp, "+++ %s %ld\n", rname, (long int) rline);
+		    else
+		      fprintf (tmp, "+++ %s %ld,%ld\n", rname,
+			       (long int) rline,
+			       (long int) (rline + rlen - 1));
+		  }
+		/* Fall through.  */
+	      case '2': case 'b': case 'r':
+		lf_copy (right, rlen, tmp);
+		break;
+
+	      default:
+		lf_skip (right, rlen);
+		break;
+	      }
+
+	    ck_fclose (tmp);
+
+	    {
+	      int wstatus;
+	      int werrno = 0;
+	      ignore_SIGINT = true;
+	      checksigs ();
+
+	      {
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+		char *command =
+		  xmalloc (shell_quote_length (editor_program)
+			   + 1 + strlen (tmpname) + 1);
+		sprintf (shell_quote_copy (command, editor_program),
+			 " %s", tmpname);
+		wstatus = system (command);
+		if (wstatus == -1)
+		  werrno = errno;
+		free (command);
+#else
+		pid_t pid;
+
+		pid = vfork ();
+		if (pid == 0)
+		  {
+		    char const *argv[3];
+		    int i = 0;
+
+		    argv[i++] = editor_program;
+		    argv[i++] = tmpname;
+		    argv[i] = 0;
+
+		    execvp (editor_program, (char **) argv);
+		    _exit (errno == ENOENT ? 127 : 126);
+		  }
+
+		if (pid < 0)
+		  perror_fatal ("fork");
+
+		while (waitpid (pid, &wstatus, 0) < 0)
+		  if (errno == EINTR)
+		    checksigs ();
+		  else
+		    perror_fatal ("waitpid");
+#endif
+	      }
+
+	      ignore_SIGINT = false;
+	      check_child_status (werrno, wstatus, EXIT_SUCCESS,
+				  editor_program);
+	    }
+
+	    {
+	      char buf[SDIFF_BUFSIZE];
+	      size_t size;
+	      tmp = ck_fopen (tmpname, "r");
+	      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
+		{
+		  checksigs ();
+		  ck_fwrite (buf, size, outfile);
+		}
+	      ck_fclose (tmp);
+	    }
+	    return true;
+	  }
+	default:
+	  give_help ();
+	  break;
+	}
+    }
+}
+
+/* Alternately reveal bursts of diff output and handle user commands.  */
+static bool
+interact (struct line_filter *diff,
+	  struct line_filter *left, char const *lname,
+	  struct line_filter *right, char const *rname,
+	  FILE *outfile)
+{
+  lin lline = 1, rline = 1;
+
+  for (;;)
+    {
+      char diff_help[256];
+      int snarfed = lf_snarf (diff, diff_help, sizeof diff_help);
+
+      if (snarfed <= 0)
+	return snarfed != 0;
+
+      checksigs ();
+
+      if (diff_help[0] == ' ')
+	puts (diff_help + 1);
+      else
+	{
+	  char *numend;
+	  uintmax_t val;
+	  lin llen, rlen, lenmax;
+	  errno = 0;
+	  llen = val = strtoumax (diff_help + 1, &numend, 10);
+	  if (llen < 0 || llen != val || errno || *numend != ',')
+	    fatal (diff_help);
+	  rlen = val = strtoumax (numend + 1, &numend, 10);
+	  if (rlen < 0 || rlen != val || errno || *numend)
+	    fatal (diff_help);
+
+	  lenmax = MAX (llen, rlen);
+
+	  switch (diff_help[0])
+	    {
+	    case 'i':
+	      if (suppress_common_lines)
+		lf_skip (diff, lenmax);
+	      else
+		lf_copy (diff, lenmax, stdout);
+
+	      lf_copy (left, llen, outfile);
+	      lf_skip (right, rlen);
+	      break;
+
+	    case 'c':
+	      lf_copy (diff, lenmax, stdout);
+	      if (! edit (left, lname, lline, llen,
+			  right, rname, rline, rlen,
+			  outfile))
+		return false;
+	      break;
+
+	    default:
+	      fatal (diff_help);
+	    }
+
+	  lline += llen;
+	  rline += rlen;
+	}
+    }
+}
+
+/* Return true if DIR is an existing directory.  */
+static bool
+diraccess (char const *dir)
+{
+  struct stat buf;
+  return stat (dir, &buf) == 0 && S_ISDIR (buf.st_mode);
+}
+
+#ifndef P_tmpdir
+# define P_tmpdir "/tmp"
+#endif
+#ifndef TMPDIR_ENV
+# define TMPDIR_ENV "TMPDIR"
+#endif
+
+/* Open a temporary file and return its file descriptor.  Put into
+   tmpname the address of a newly allocated buffer that holds the
+   file's name.  Use the prefix "sdiff".  */
+static int
+temporary_file (void)
+{
+  char const *tmpdir = getenv (TMPDIR_ENV);
+  char const *dir = tmpdir ? tmpdir : P_tmpdir;
+  char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+  int fd;
+  int e;
+  sigset_t procmask;
+  sigset_t blocked;
+  sprintf (buf, "%s/sdiffXXXXXX", dir);
+  sigemptyset (&blocked);
+  sigaddset (&blocked, SIGINT);
+  sigprocmask (SIG_BLOCK, &blocked, &procmask);
+  fd = mkstemp (buf);
+  e = errno;
+  if (0 <= fd)
+    tmpname = buf;
+  sigprocmask (SIG_SETMASK, &procmask, 0);
+  errno = e;
+  return fd;
+}
diff --git a/src/util.c.orig b/src/util.c.orig
new file mode 100644
index 0000000..b645c5b
--- /dev/null
+++ b/src/util.c.orig
@@ -0,0 +1,788 @@
+/* Support routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <dirname.h>
+#include <error.h>
+#include <sh-quote.h>
+#include <xalloc.h>
+
+char const pr_program[] = PR_PROGRAM;
+
+/* Queue up one-line messages to be printed at the end,
+   when -l is specified.  Each message is recorded with a `struct msg'.  */
+
+struct msg
+{
+  struct msg *next;
+  char args[1]; /* Format + 4 args, each '\0' terminated, concatenated.  */
+};
+
+/* Head of the chain of queues messages.  */
+
+static struct msg *msg_chain;
+
+/* Tail of the chain of queues messages.  */
+
+static struct msg **msg_chain_end = &msg_chain;
+
+/* Use when a system call returns non-zero status.
+   NAME should normally be the file name.  */
+
+void
+perror_with_name (char const *name)
+{
+  error (0, errno, "%s", name);
+}
+
+/* Use when a system call returns non-zero status and that is fatal.  */
+
+void
+pfatal_with_name (char const *name)
+{
+  int e = errno;
+  print_message_queue ();
+  error (EXIT_TROUBLE, e, "%s", name);
+  abort ();
+}
+
+/* Print an error message containing MSGID, then exit.  */
+
+void
+fatal (char const *msgid)
+{
+  print_message_queue ();
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+/* Like printf, except if -l in effect then save the message and print later.
+   This is used for things like "Only in ...".  */
+
+void
+message (char const *format_msgid, char const *arg1, char const *arg2)
+{
+  message5 (format_msgid, arg1, arg2, 0, 0);
+}
+
+void
+message5 (char const *format_msgid, char const *arg1, char const *arg2,
+	  char const *arg3, char const *arg4)
+{
+  if (paginate)
+    {
+      char *p;
+      char const *arg[5];
+      int i;
+      size_t size[5];
+      size_t total_size = offsetof (struct msg, args);
+      struct msg *new;
+
+      arg[0] = format_msgid;
+      arg[1] = arg1;
+      arg[2] = arg2;
+      arg[3] = arg3 ? arg3 : "";
+      arg[4] = arg4 ? arg4 : "";
+
+      for (i = 0;  i < 5;  i++)
+	total_size += size[i] = strlen (arg[i]) + 1;
+
+      new = xmalloc (total_size);
+
+      for (i = 0, p = new->args;  i < 5;  p += size[i++])
+	memcpy (p, arg[i], size[i]);
+
+      *msg_chain_end = new;
+      new->next = 0;
+      msg_chain_end = &new->next;
+    }
+  else
+    {
+      if (sdiff_merge_assist)
+	putchar (' ');
+      printf (_(format_msgid), arg1, arg2, arg3, arg4);
+    }
+}
+
+/* Output all the messages that were saved up by calls to 'message'.  */
+
+void
+print_message_queue (void)
+{
+  char const *arg[5];
+  int i;
+  struct msg *m = msg_chain;
+
+  while (m)
+    {
+      struct msg *next = m->next;
+      arg[0] = m->args;
+      for (i = 0;  i < 4;  i++)
+	arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
+      printf (_(arg[0]), arg[1], arg[2], arg[3], arg[4]);
+      free (m);
+      m = next;
+    }
+}
+
+/* Call before outputting the results of comparing files NAME0 and NAME1
+   to set up OUTFILE, the stdio stream for the output to go to.
+
+   Usually, OUTFILE is just stdout.  But when -l was specified
+   we fork off a 'pr' and make OUTFILE a pipe to it.
+   'pr' then outputs to our stdout.  */
+
+static char const *current_name0;
+static char const *current_name1;
+static bool currently_recursive;
+
+void
+setup_output (char const *name0, char const *name1, bool recursive)
+{
+  current_name0 = name0;
+  current_name1 = name1;
+  currently_recursive = recursive;
+  outfile = 0;
+}
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t pr_pid;
+#endif
+
+void
+begin_output (void)
+{
+  char *name;
+
+  if (outfile != 0)
+    return;
+
+  /* Construct the header of this piece of diff.  */
+  name = xmalloc (strlen (current_name0) + strlen (current_name1)
+		  + strlen (switch_string) + 7);
+
+  /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+     the standard: it says that we must print only the last component
+     of the pathnames, and it requires two spaces after "diff" if
+     there are no options.  These requirements are silly and do not
+     match historical practice.  */
+  sprintf (name, "diff%s %s %s", switch_string, current_name0, current_name1);
+
+  if (paginate)
+    {
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("write failed"));
+
+      /* Make OUTFILE a pipe to a subsidiary 'pr'.  */
+      {
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+	int pipes[2];
+
+	if (pipe (pipes) != 0)
+	  pfatal_with_name ("pipe");
+
+	pr_pid = vfork ();
+	if (pr_pid < 0)
+	  pfatal_with_name ("fork");
+
+	if (pr_pid == 0)
+	  {
+	    close (pipes[1]);
+	    if (pipes[0] != STDIN_FILENO)
+	      {
+		if (dup2 (pipes[0], STDIN_FILENO) < 0)
+		  pfatal_with_name ("dup2");
+		close (pipes[0]);
+	      }
+
+	    execl (pr_program, pr_program, "-h", name, (char *) 0);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+	else
+	  {
+	    close (pipes[0]);
+	    outfile = fdopen (pipes[1], "w");
+	    if (!outfile)
+	      pfatal_with_name ("fdopen");
+	  }
+#else
+	char *command = xmalloc (sizeof pr_program - 1 + 7
+				 + shell_quote_length (name) + 1);
+	char *p;
+	sprintf (command, "%s -f -h ", pr_program);
+	p = command + sizeof pr_program - 1 + 7;
+	p = shell_quote_copy (p, name);
+	*p = 0;
+	errno = 0;
+	outfile = popen (command, "w");
+	if (!outfile)
+	  pfatal_with_name (command);
+	free (command);
+#endif
+      }
+    }
+  else
+    {
+
+      /* If -l was not specified, output the diff straight to 'stdout'.  */
+
+      outfile = stdout;
+
+      /* If handling multiple files (because scanning a directory),
+	 print which files the following output is about.  */
+      if (currently_recursive)
+	printf ("%s\n", name);
+    }
+
+  free (name);
+
+  /* A special header is needed at the beginning of context output.  */
+  switch (output_style)
+    {
+    case OUTPUT_CONTEXT:
+      print_context_header (files, false);
+      break;
+
+    case OUTPUT_UNIFIED:
+      print_context_header (files, true);
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Call after the end of output of diffs for one file.
+   Close OUTFILE and get rid of the 'pr' subfork.  */
+
+void
+finish_output (void)
+{
+  if (outfile != 0 && outfile != stdout)
+    {
+      int status;
+      int wstatus;
+      int werrno = 0;
+      if (ferror (outfile))
+	fatal ("write failed");
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      wstatus = pclose (outfile);
+      if (wstatus == -1)
+	werrno = errno;
+#else
+      if (fclose (outfile) != 0)
+	pfatal_with_name (_("write failed"));
+      if (waitpid (pr_pid, &wstatus, 0) < 0)
+	pfatal_with_name ("waitpid");
+#endif
+      status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+      if (status)
+	error (EXIT_TROUBLE, werrno,
+	       _(status == 126
+		 ? "subsidiary program '%s' could not be invoked"
+		 : status == 127
+		 ? "subsidiary program '%s' not found"
+		 : status == INT_MAX
+		 ? "subsidiary program '%s' failed"
+		 : "subsidiary program '%s' failed (exit status %d)"),
+	       pr_program, status);
+    }
+
+  outfile = 0;
+}
+
+/* Compare two lines (typically one from each input file)
+   according to the command line options.
+   For efficiency, this is invoked only when the lines do not match exactly
+   but an option like -i might cause us to ignore the difference.
+   Return nonzero if the lines differ.  */
+
+bool
+lines_differ (char const *s1, char const *s2)
+{
+  register char const *t1 = s1;
+  register char const *t2 = s2;
+  size_t column = 0;
+
+  while (1)
+    {
+      register unsigned char c1 = *t1++;
+      register unsigned char c2 = *t2++;
+
+      /* Test for exact char equality first, since it's a common case.  */
+      if (c1 != c2)
+	{
+	  switch (ignore_white_space)
+	    {
+	    case IGNORE_ALL_SPACE:
+	      /* For -w, just skip past any white space.  */
+	      while (isspace (c1) && c1 != '\n') c1 = *t1++;
+	      while (isspace (c2) && c2 != '\n') c2 = *t2++;
+	      break;
+
+	    case IGNORE_SPACE_CHANGE:
+	      /* For -b, advance past any sequence of white space in
+		 line 1 and consider it just one space, or nothing at
+		 all if it is at the end of the line.  */
+	      if (isspace (c1))
+		{
+		  while (c1 != '\n')
+		    {
+		      c1 = *t1++;
+		      if (! isspace (c1))
+			{
+			  --t1;
+			  c1 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      /* Likewise for line 2.  */
+	      if (isspace (c2))
+		{
+		  while (c2 != '\n')
+		    {
+		      c2 = *t2++;
+		      if (! isspace (c2))
+			{
+			  --t2;
+			  c2 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      if (c1 != c2)
+		{
+		  /* If we went too far when doing the simple test
+		     for equality, go back to the first non-white-space
+		     character in both sides and try again.  */
+		  if (c2 == ' ' && c1 != '\n'
+		      && s1 + 1 < t1
+		      && isspace ((unsigned char) t1[-2]))
+		    {
+		      --t1;
+		      continue;
+		    }
+		  if (c1 == ' ' && c2 != '\n'
+		      && s2 + 1 < t2
+		      && isspace ((unsigned char) t2[-2]))
+		    {
+		      --t2;
+		      continue;
+		    }
+		}
+
+	      break;
+
+	    case IGNORE_TAB_EXPANSION:
+	      if ((c1 == ' ' && c2 == '\t')
+		  || (c1 == '\t' && c2 == ' '))
+		{
+		  size_t column2 = column;
+		  for (;; c1 = *t1++)
+		    {
+		      if (c1 == ' ')
+			column++;
+		      else if (c1 == '\t')
+			column += tabsize - column % tabsize;
+		      else
+			break;
+		    }
+		  for (;; c2 = *t2++)
+		    {
+		      if (c2 == ' ')
+			column2++;
+		      else if (c2 == '\t')
+			column2 += tabsize - column2 % tabsize;
+		      else
+			break;
+		    }
+		  if (column != column2)
+		    return true;
+		}
+	      break;
+
+	    case IGNORE_NO_WHITE_SPACE:
+	      break;
+	    }
+
+	  /* Lowercase all letters if -i is specified.  */
+
+	  if (ignore_case)
+	    {
+	      c1 = tolower (c1);
+	      c2 = tolower (c2);
+	    }
+
+	  if (c1 != c2)
+	    break;
+	}
+      if (c1 == '\n')
+	return false;
+
+      column += c1 == '\t' ? tabsize - column % tabsize : 1;
+    }
+
+  return true;
+}
+
+/* Find the consecutive changes at the start of the script START.
+   Return the last link before the first gap.  */
+
+struct change *
+find_change (struct change *start)
+{
+  return start;
+}
+
+struct change *
+find_reverse_change (struct change *start)
+{
+  return start;
+}
+
+/* Divide SCRIPT into pieces by calling HUNKFUN and
+   print each piece with PRINTFUN.
+   Both functions take one arg, an edit script.
+
+   HUNKFUN is called with the tail of the script
+   and returns the last link that belongs together with the start
+   of the tail.
+
+   PRINTFUN takes a subscript which belongs together (with a null
+   link at the end) and prints it.  */
+
+void
+print_script (struct change *script,
+	      struct change * (*hunkfun) (struct change *),
+	      void (*printfun) (struct change *))
+{
+  struct change *next = script;
+
+  while (next)
+    {
+      struct change *this, *end;
+
+      /* Find a set of changes that belong together.  */
+      this = next;
+      end = (*hunkfun) (next);
+
+      /* Disconnect them from the rest of the changes,
+	 making them a hunk, and remember the rest for next iteration.  */
+      next = end->link;
+      end->link = 0;
+#ifdef DEBUG
+      debug_script (this);
+#endif
+
+      /* Print this hunk.  */
+      (*printfun) (this);
+
+      /* Reconnect the script so it will all be freed properly.  */
+      end->link = next;
+    }
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  */
+
+void
+print_1_line (char const *line_flag, char const *const *line)
+{
+  char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+  FILE *out = outfile; /* Help the compiler some more.  */
+  char const *flag_format = 0;
+
+  /* If -T was specified, use a Tab between the line-flag and the text.
+     Otherwise use a Space (as Unix diff does).
+     Print neither space nor tab if line-flags are empty.
+     But omit trailing blanks if requested.  */
+
+  if (line_flag && *line_flag)
+    {
+      char const *flag_format_1 = flag_format = initial_tab ? "%s\t" : "%s ";
+      char const *line_flag_1 = line_flag;
+
+      if (suppress_blank_empty && **line == '\n')
+	{
+	  flag_format_1 = "%s";
+
+	  /* This hack to omit trailing blanks takes advantage of the
+	     fact that the only way that LINE_FLAG can end in a blank
+	     is when LINE_FLAG consists of a single blank.  */
+	  line_flag_1 += *line_flag_1 == ' ';
+	}
+
+      fprintf (out, flag_format_1, line_flag_1);
+    }
+
+  output_1_line (base, limit, flag_format, line_flag);
+
+  if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+    fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+}
+
+/* Output a line from BASE up to LIMIT.
+   With -t, expand white space characters to spaces, and if FLAG_FORMAT
+   is nonzero, output it with argument LINE_FLAG after every
+   internal carriage return, so that tab stops continue to line up.  */
+
+void
+output_1_line (char const *base, char const *limit, char const *flag_format,
+	       char const *line_flag)
+{
+  if (!expand_tabs)
+    fwrite (base, sizeof (char), limit - base, outfile);
+  else
+    {
+      register FILE *out = outfile;
+      register unsigned char c;
+      register char const *t = base;
+      register size_t column = 0;
+      size_t tab_size = tabsize;
+
+      while (t < limit)
+	switch ((c = *t++))
+	  {
+	  case '\t':
+	    {
+	      size_t spaces = tab_size - column % tab_size;
+	      column += spaces;
+	      do
+		putc (' ', out);
+	      while (--spaces);
+	    }
+	    break;
+
+	  case '\r':
+	    putc (c, out);
+	    if (flag_format && t < limit && *t != '\n')
+	      fprintf (out, flag_format, line_flag);
+	    column = 0;
+	    break;
+
+	  case '\b':
+	    if (column == 0)
+	      continue;
+	    column--;
+	    putc (c, out);
+	    break;
+
+	  default:
+	    column += isprint (c) != 0;
+	    putc (c, out);
+	    break;
+	  }
+    }
+}
+
+char const change_letter[] = { 0, 'd', 'a', 'c' };
+
+/* Translate an internal line number (an index into diff's table of lines)
+   into an actual line number in the input file.
+   The internal line number is I.  FILE points to the data on the file.
+
+   Internal line numbers count from 0 starting after the prefix.
+   Actual line numbers count from 1 within the entire file.  */
+
+lin
+translate_line_number (struct file_data const *file, lin i)
+{
+  return i + file->prefix_lines + 1;
+}
+
+/* Translate a line number range.  This is always done for printing,
+   so for convenience translate to long int rather than lin, so that the
+   caller can use printf with "%ld" without casting.  */
+
+void
+translate_range (struct file_data const *file,
+		 lin a, lin b,
+		 long int *aptr, long int *bptr)
+{
+  *aptr = translate_line_number (file, a - 1) + 1;
+  *bptr = translate_line_number (file, b + 1) - 1;
+}
+
+/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
+   If the two numbers are identical, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+void
+print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* Note: we can have B < A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.  */
+  if (trans_b > trans_a)
+    fprintf (outfile, "%ld%c%ld", trans_a, sepchar, trans_b);
+  else
+    fprintf (outfile, "%ld", trans_b);
+}
+
+/* Look at a hunk of edit script and report the range of lines in each file
+   that it applies to.  HUNK is the start of the hunk, which is a chain
+   of 'struct change'.  The first and last line numbers of file 0 are stored in
+   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+   Note that these are internal line numbers that count from 0.
+
+   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.
+
+   Return UNCHANGED if only ignorable lines are inserted or deleted,
+   OLD if lines of file 0 are deleted,
+   NEW if lines of file 1 are inserted,
+   and CHANGED if both kinds of changes are found. */
+
+enum changes
+analyze_hunk (struct change *hunk,
+	      lin *first0, lin *last0,
+	      lin *first1, lin *last1)
+{
+  struct change *next;
+  lin l0, l1;
+  lin show_from, show_to;
+  lin i;
+  bool trivial = ignore_blank_lines || ignore_regexp.fastmap;
+  size_t trivial_length = ignore_blank_lines - 1;
+    /* If 0, ignore zero-length lines;
+       if SIZE_MAX, do not ignore lines just because of their length.  */
+  bool skip_leading_white_space =
+    (ignore_blank_lines && IGNORE_SPACE_CHANGE <= ignore_white_space);
+
+  char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+  char const * const *linbuf1 = files[1].linbuf;
+
+  show_from = show_to = 0;
+
+  *first0 = hunk->line0;
+  *first1 = hunk->line1;
+
+  next = hunk;
+  do
+    {
+      l0 = next->line0 + next->deleted - 1;
+      l1 = next->line1 + next->inserted - 1;
+      show_from += next->deleted;
+      show_to += next->inserted;
+
+      for (i = next->line0; i <= l0 && trivial; i++)
+	{
+	  char const *line = linbuf0[i];
+	  char const *newline = linbuf0[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+
+      for (i = next->line1; i <= l1 && trivial; i++)
+	{
+	  char const *line = linbuf1[i];
+	  char const *newline = linbuf1[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+    }
+  while ((next = next->link) != 0);
+
+  *last0 = l0;
+  *last1 = l1;
+
+  /* If all inserted or deleted lines are ignorable,
+     tell the caller to ignore this hunk.  */
+
+  if (trivial)
+    return UNCHANGED;
+
+  return (show_from ? OLD : UNCHANGED) | (show_to ? NEW : UNCHANGED);
+}
+
+/* Concatenate three strings, returning a newly malloc'd string.  */
+
+char *
+concat (char const *s1, char const *s2, char const *s3)
+{
+  char *new = xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
+  sprintf (new, "%s%s%s", s1, s2, s3);
+  return new;
+}
+
+/* Yield a new block of SIZE bytes, initialized to zero.  */
+
+void *
+zalloc (size_t size)
+{
+  void *p = xmalloc (size);
+  memset (p, 0, size);
+  return p;
+}
+
+/* Yield the newly malloc'd pathname
+   of the file in DIR whose filename is FILE.  */
+
+char *
+dir_file_pathname (char const *dir, char const *file)
+{
+  char const *base = last_component (dir);
+  size_t baselen = base_len (base);
+  bool omit_slash = baselen == 0 || base[baselen - 1] == '/';
+  return concat (dir, "/" + omit_slash, file);
+}
+
+void
+debug_script (struct change *sp)
+{
+  fflush (stdout);
+
+  for (; sp; sp = sp->link)
+    {
+      long int line0 = sp->line0;
+      long int line1 = sp->line1;
+      long int deleted = sp->deleted;
+      long int inserted = sp->inserted;
+      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
+	       line0, line1, deleted, inserted);
+    }
+
+  fflush (stderr);
+}
-- 
1.8.5.3

